{"meta":{"title":"superKM的博客","subtitle":"superKM","description":"superKM的个人博客","author":"superKM","url":"http://superliebe.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-24T08:46:04.913Z","updated":"2020-05-24T08:46:04.913Z","comments":true,"path":"404.html","permalink":"http://superliebe.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-07-31T05:27:49.501Z","updated":"2020-07-31T05:27:49.501Z","comments":false,"path":"about/index.html","permalink":"http://superliebe.github.io/about/index.html","excerpt":"","text":".card { --card-bg-color: hsl(240, 31%, 25%); --card-bg-color-transparent: hsla(240, 31%, 25%, 0.7); position: relative; width: 300px; } .card .card-borders { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; } .card .card-borders .border-top { position: absolute; top: 0; width: 100%; height: 2px; background: var(--card-bg-color); transform: translateX(-100%); animation: slide-in-horizontal 0.8s cubic-bezier(0.645, 0.045, 0.355, 1) forwards; } .card .card-borders .border-right { position: absolute; right: 0; width: 2px; height: 100%; background: var(--card-bg-color); transform: translateY(100%); animation: slide-in-vertical 0.8s cubic-bezier(0.645, 0.045, 0.355, 1) forwards; } .card .card-borders .border-bottom { position: absolute; bottom: 0; width: 100%; height: 2px; background: var(--card-bg-color); transform: translateX(100%); animation: slide-in-horizontal-reverse 0.8s cubic-bezier(0.645, 0.045, 0.355, 1) forwards; } .card .card-borders .border-left { position: absolute; top: 0; width: 2px; height: 100%; background: var(--card-bg-color); transform: translateY(-100%); animation: slide-in-vertical-reverse 0.8s cubic-bezier(0.645, 0.045, 0.355, 1) forwards; } .card .card-content { display: flex; flex-direction: column; align-items: center; padding: 40px 0 40px 0; font-family: Lato, sans-serif; background: var(--card-bg-color-transparent); box-shadow: 0 0px 0.6px rgba(0, 0, 0, 0.028), 0 0px 1.3px rgba(0, 0, 0, 0.04), 0 0px 2.5px rgba(0, 0, 0, 0.05), 0 0px 4.5px rgba(0, 0, 0, 0.06), 0 0px 8.4px rgba(0, 0, 0, 0.072), 0 0px 20px rgba(0, 0, 0, 0.1); opacity: 0; transform: scale(0.6); animation: bump-in 0.5s 0.8s forwards; } .card .card-content .avatar { width: 120px; height: 120px; border-radius: 50%; margin-bottom: 40px; opacity: 0; transform: scale(0.6); animation: bump-in 0.5s 1s forwards; } .card .card-content .username { position: relative; font-size: 26px; letter-spacing: 2px; margin-bottom: 40px; color: transparent; animation: fill-text-white 1.2s 2s forwards; } .card .card-content .username::before { position: absolute; content: \"\"; top: 0; left: 0; width: 100%; height: 100%; color: black; background: #35b9f1; transform: scaleX(0); transform-origin: left; animation: slide-in-out 1.2s 1.2s cubic-bezier(0.75, 0, 0, 1) forwards; } .card .card-content .social-icons { display: flex; position:relative; } .card .card-content .social-icons .social-icon { position: relative; display: flex; justify-content: center; align-items: center; width: 2.5em; height: 2.5em; margin: 0 15px; border-radius: 50%; color: white; text-decoration: none; } .card .card-content .social-icons .social-icon:nth-child(1)::before { animation-delay: 2.1s; } .card .card-content .social-icons .social-icon:nth-child(1)::after { animation-delay: 2.2s; } .card .card-content .social-icons .social-icon:nth-child(1) svg { animation-delay: 2.3s; } .card .card-content .social-icons .social-icon:nth-child(2)::before { animation-delay: 2.2s; } .card .card-content .social-icons .social-icon:nth-child(2)::after { animation-delay: 2.3s; } .card .card-content .social-icons .social-icon:nth-child(2) svg { animation-delay: 2.4s; } .card .card-content .social-icons .social-icon:nth-child(3)::before { animation-delay: 2.3s; } .card .card-content .social-icons .social-icon:nth-child(3)::after { animation-delay: 2.4s; } .card .card-content .social-icons .social-icon:nth-child(3) svg { animation-delay: 2.5s; } .card .card-content .social-icons .social-icon::before, .card .card-content .social-icons .social-icon::after { position: absolute; content: \"\"; top: 0; left: 0; width: 100%; height: 100%; border-radius: inherit; transform: scale(0); } .card .card-content .social-icons .social-icon::before { background: #f7f1e3; animation: scale-in 0.5s cubic-bezier(0.75, 0, 0, 1) forwards; } .card .card-content .social-icons .social-icon::after { background: #2C3E50; animation: scale-in 0.5s cubic-bezier(0.75, 0, 0, 1) forwards; } .card .card-content .social-icons .social-icon svg { z-index: 1; transform: scale(0); animation: scale-in 0.5s cubic-bezier(0.75, 0, 0, 1) forwards; } .card .card-content .card_wx:hover>.qrcode{ opacity:1; bottom: -83px; } .card .card-content .card_wx .qrcode{ width: 124px; border: 6px solid #FFF; border-radius: 9px; position: absolute!important; right: -136px; bottom: -43px; opacity:0; max-width: 1000%; box-shadow: 2px 2px 10px 2px #e8e8e8; } @keyframes bump-in { 50% { transform: scale(1.05); } to { opacity: 1; transform: scale(1); } } @keyframes slide-in-horizontal { 50% { transform: translateX(0); } to { transform: translateX(100%); } } @keyframes slide-in-horizontal-reverse { 50% { transform: translateX(0); } to { transform: translateX(-100%); } } @keyframes slide-in-vertical { 50% { transform: translateY(0); } to { transform: translateY(-100%); } } @keyframes slide-in-vertical-reverse { 50% { transform: translateY(0); } to { transform: translateY(100%); } } @keyframes slide-in-out { 50% { transform: scaleX(1); transform-origin: left; } 50.1% { transform-origin: right; } 100% { transform: scaleX(0); transform-origin: right; } } @keyframes fill-text-white { to { color: white; } } @keyframes scale-in { to { transform: scale(1); } } 一个前端菜菜 😶 个人情况 郑州大学毕业 热爱开源，热爱技术，热爱探索、热爱生活、热爱身边的一切。 😝 擅长领域 vue全家桶，桶装干净又卫生 微信小程序开发 ，微信网页开发，移动webApp开发 jquery 框架 ， ES6语法 ，Git，sass语法 Docker 部署项目 Nginx 代理 nodejs ，webpack kbone + vue 同时支持web和小程序 tradingview K 线图制作 pwa 渐进式web应用 vite+vue3 TypeScript 语法 常用开发工具 微信开发者工具、vscode、mysqlWorkbench、ps6、蓝湖、IDEA、webstorm 、Fiddle、Postman、磨刀。 🧐 探索学习中 Flutter 跨平台多端webApp开发 koa2 基于nodejs 下一代web开发框架 noSql 非关系型的数据库 🙃 CSDN 博客 – superKM😇 期望 前端全栈攻城狮占领全地球，奥里给！"},{"title":"所有分类","date":"2020-05-24T08:23:24.038Z","updated":"2020-05-24T08:23:24.038Z","comments":true,"path":"categories/index.html","permalink":"http://superliebe.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-24T08:44:21.697Z","updated":"2020-05-24T08:44:21.697Z","comments":true,"path":"tags/index.html","permalink":"http://superliebe.github.io/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-05-24T13:52:18.053Z","updated":"2020-05-24T13:52:18.053Z","comments":true,"path":"friends/index.html","permalink":"http://superliebe.github.io/friends/index.html","excerpt":"推荐一个技术博主","text":"推荐一个技术博主"},{"title":"","date":"2020-05-24T08:45:19.617Z","updated":"2020-05-24T08:45:19.617Z","comments":true,"path":"mylist/index.html","permalink":"http://superliebe.github.io/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"前端性能优化","slug":"前端性能优化","date":"2020-07-31T03:23:51.000Z","updated":"2020-08-05T14:08:06.371Z","comments":true,"path":"2020/07/31/前端性能优化/","link":"","permalink":"http://superliebe.github.io/2020/07/31/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"网站性能的好坏可以说直接决定了用户体验的好坏，而互联网的本质还是为人服务，因此极致的用户体验我想是每个公司都在追求的目标","text":"网站性能的好坏可以说直接决定了用户体验的好坏，而互联网的本质还是为人服务，因此极致的用户体验我想是每个公司都在追求的目标 打开一个 url 地址，浏览器都做了什么，只有理解了做了哪些事情，才知道如何针对优化。 浏览器能访问的资源都是通过 IP 访问的，但是为了方便我们记忆和使用网站都是使用的域名，所以当我们输入一个域名的时候就需要浏览器进行域名解析。 缓存中查找 浏览器缓存中查找（浏览器会缓存 DNS 一段时间）–&gt;系统 host 文件缓存中查找–&gt;路由器缓存中查找–&gt; DNS 域名解析 本地域名服务器–&gt;其他服务器查找（根域名服务器，一级域名服务器，二级域名服务器，三级域名服务器）。 从而解析到对应的 IP，浏览器主机根据 ip 地址与服务器建立 TCP 连接。 TCP 三次握手 域名解析成功之后，客户端和服务器端就会有三次握手，试探链接，用语义化的语言解释就是。 客户端 —-&gt; 服务器端 你好，我们可以链接吗 服务器端 —-&gt;客户端 可以，你确定要连接是吧？ 客户端—-&gt;服务器端 确定，我们链接吧 发送 http 请求，接收 http 响应 连接成功之后就可以开始传输数据了，传输数据需要将用户输入的 URL 封装成 HTTP Request 请求报文，发送到服务器，服务器收到请求后会发出应答，即响应数据。 断开 TCP 连接（4 次挥手） 客户端—&gt; 服务器端 好了，我们断开连接吧？ 服务端—&gt; 客户端 好的，我在检查一哈有没有需要在发给你的信息？ 服务端—&gt; 客户端 好了，我们可以断开连接了 客户端—&gt; 服务端 好的 浏览器解析 浏览器通过解析HTML，生成 DOM 树，解析CSS，生成 CSS 规则树，然后通过 DOM 树和 CSS 规则树生成渲染树。 根据渲染树布局，计算 CSS 样式，即每个节点在页面中的大小和位置等几何信息。HTML 默认是流式布局的，CSS 和 js 会打破这种布局，改变 DOM 的外观样式以及大小和位置。这时就要提到两个重要概念：repaint(重绘)和 reflow(回流)。 repaint：屏幕的一部分重画，不影响整体布局，比如某个 CSS 的背景色变了，但元素的几何尺寸和位置不变。 reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是 Reflow，或是 Layout。 性能优化工具 LightHouse LightHouse 是 Google 开源的一个自动化工具，用于改进网络应用的质量。你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 当为 Lighthouse 提供一个要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。可以参考失败的测试，看看可以采取哪些措施来改进应用。 ——谷歌应用商店介绍 首先我们可以到谷歌应用商店安装 LightHouse，点击添加至 Chrome 即可 如果你的浏览器版本较新的话，可以直接打开 Chrome 开发者工具 (F12)，然后打开 Audits 面板即可。Audits 面板就是集成了 LightHouse 功能的面板，我们可以根据自己的需要，选择对应的限制条件，运行 Run audits 点击 run audits 就会自动帮我们生成性能优化报告。 这里推荐我们使用下一代图片格式化的技术，原因是 JPEG 2000、JPEG XR 和 WebP 等图像格式通常比 PNG 或 JPEG 提供更好的压缩，这意味着更快的下载速度和更少的数据消耗。 网络部分DNS Prefetch 优化原理 当我们访问https://www.baidu.com的时候，首先就需要把域名转化为对应的IP地址，DNS本身的解析是一个非常耗时的过程，打开DNS Prefetch 之后，浏览器会在空闲时间提前将这些域名转化为对应的 IP 地址，这里为了防止 DNS Prefetch 阻塞页面渲染影响用户体验，Chrome 浏览器的引擎并没有使用它的网络堆栈去进行预解析，而是单独开了 8 个完全异步的 Worker 线程专门负责 DNS Prefetch。 如何使用 浏览器自动解析：浏览器引擎在解析 HTML 页面的时候，会自动获取当前页面所有的 a 标签 herf 属性当中的域名，然后进行 DNS Prefetch。这里需要注意的是如果你的页面是 HTTPS，那么浏览器为了确保安全是不会开启自动解析的，这个时候我们就需要在页面头部添加如下的 meta 标签： 1&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\" /&gt; 如果你不希望浏览器开启自动解析，我们添加如下 meta 标签： 1&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"off\" /&gt; 手动解析：直接添加如下 link 标签即可： 1&lt;link rel=\"dns-prefetch\" href=\"//www.baidu.com\" /&gt; DNS Prefetch 通过提前解析我们用到的一些常见域名，大大减少了实际访问时所花费的时间，是一个非常好的解决方案，而且如果你所在的公司有国际化的业务，合理地运用 DNS Prefetch 相信可以带来不错的效果。最后这里要说明一点，DNS Prefetch 的数量不是越多越好，大多数情况下我们设置 3-5 个常用的即可，多了反而会适得其反，毕竟 DNS Prefetch 也是会占用设备宽带。 Webpack 性能优化构建速度优化 npm install 过程中的优化 现在一个普通的前端项目中就有几百个包，加上每个包都有相关的依赖，可想而知工作量有多大。优化的办法也很简单，就是增加版本描述文件。 具体仓库地址的选择 推荐使用淘宝提供的 npm 仓库 1npm config set registry https://registry.npm.taobao.org 提升 Webpack 构建速度 Webpack 的打包流程 可以将其理解为一个函数，配置文件则是其参数，传入合理的参数后，运行函数就能得到我们想要的结果。 减少不必要的编译，我们在使用 loader 处理文件的时候，应该尽量把文件范围缩小，对于一些不需要处理的文件直接忽略。 12345678910111213141516171819module: &#123; rules: [ &#123; //处理后缀名为js的文件 test: /\\.js$/, //exclude去掉不需要转译的第三方包 &amp;&amp; 或者这里使用include去声明哪些文件需要被处理 exclude: /(node_modules|bower_components)/, //babel的常用配置项 use: &#123; loader: \"babel-loader\", options: &#123; presets: [\"@babel/preset-env\"], //缓存设置为开启 cacheDirectory: true, &#125;, &#125;, &#125;, ];&#125; 这里我们对于不需要处理的第三方包直接使用 exclude 属性排除在外，或者需要处理的文件使用 include 属性去包含，此外上面我们在 options 配置当中增加了 cacheDirectory: true，这样对于转译结果就可以直接缓存到文件系统当中，在我们下次需要的时候直接到缓存当中读取即可。 使用模块热替换(HMR)，传统的如果我们没有配置模块热替换，则需要每次刷新整个页面，效率很低。而使用模块热替换之后，我们只需要重新编译发生变化的模块，不需要编译所有模块，速度上面大大提高。具体配置方法如下： 123456789module.exports = &#123; ...... plugins: [ new webpack.HotModuleReplacementPlugin(), // 引入模块热替换插件 ], devServer: &#123; hot: true // 开启模块热替换模式 &#125;&#125; 由于现在的项目都会引用大量的第三方包，这些包基本都是不会变的，我们完全把他们打包到单独的文件当中，这就涉及到了公共代码的提取,optimization.splitChunks 插件 1234567891011121314151617optimization: &#123; splitChunks: &#123; //设置那些代码用于分割 chunks: \"all\", // 指定最小共享模块数(与CommonsChunkPlugin的minChunks类似) minChunks: 1, // 形成一个新代码块最小的体积 minSize: 0, cacheGroups: &#123; framework: &#123; test: /lodash/, name: \"vendor\", enforce: true &#125; &#125; &#125; &#125; 打包文件质量优化如何使打包出的文件尽可能的小，这样我们在加载文件的时候才能更快。 1.压缩 JavaScript 代码，在压缩 JavaScript 代码的时候我们需要先将代码解析成AST 语法树，这个过程计算量非常大，我们常用的插件是 webpack-uglify-parallel 。通过 webpack-uglify-parallel 我们可以将每个资源的压缩过程交给单独的进程，以此来提升整体的压缩效率。这个插件并不在 Webpack 内部，需要我们单独安装。配置方法也比较简单，如下： 12345678910111213141516const os = require(\"os\");const UglifyJsParallelPlugin = require(\"webpack-uglify-parallel\");new UglifyJsParallelPlugin(&#123; //开启多进程 workers: os.cpus().length, mangle: true, compressor: &#123; //忽略警告 warnings: false, //打开console drop_console: true, //打开debugger drop_debugger: true, &#125;,&#125;); 2.压缩 CSS 代码，上面我们介绍了压缩 JavaScript 代码的方法， 同样 CSS 代码同样也可以被压缩。WebPack4.x 我们用 MiniCssExtractPlugin 和 OptimizeCSSAssetsPlugin，具体配置如下： 123456789101112131415161718192021const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, // 分离css代码 \"css-loader\", ], &#125;, ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: \"static/css/[name].[contenthash:8].css\", //提取css存放目录 &#125;), new OptimizeCssAssetsPlugin(), // 使用OptimizeCssAssetsPlugin对CSS进行压缩 ],&#125;; 3.压缩图片，图片在一般项目当中都是最大的静态资源，所以图片的压缩就显得非常重要。图片压缩插件我们常用的是 imagemin-webpack-plugin。配置较为简单，如下： 1234567891011const ImageminPlugin = require(\"imagemin-webpack-plugin\").default;module.exports = &#123; plugins: [ new ImageminPlugin(&#123; pngquant: &#123; //指定压缩后的图片质量 quality: \"95-100\", &#125;, &#125;), ],&#125;; 及时升级你的 Webpack 版本来获得更优的打包速度 图片优化图片格式介绍 PNG：是一种无损压缩的位图图形格式，因此 PNG 格式的图片色彩表现力要比其他格式的图片更好，PNG 下又细分为 PNG-8、PNG-24、PNG-32。 JPG/JPEG：一种有损压缩的格式，在不影响人们可分辨图片质量的前提下，尽可能的压缩文件的大小，因此图片大小不会太大，图片质量也适中，换句话说，就是可以用最少的磁盘空间得到较好的图像质量。 GIF：一种基于 LZW 算法的连续色调的无损压缩格式，应用场景主要是一些动画的展示。 APNG：使用多个单张 PNG 连接起来的动画图片格式，支持全透明通道动画。相比于 GIF 动画，没有毛刺，质量更高，色彩效果也更好，而且它的体积相比 GIF 来说也小很多，但目前支持的浏览器并不完全。 SVG：是一种基于 XML 语法的图像格式，全称是可缩放矢量图。SVG 本身是可编程性的语言(支持直接插入 DOM 当中)，可被非常多的工具读取和修改。SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强，而且 SVG 图像可在任何的分辨率下被高质量地打印，SVG 可在图像质量不下降的情况下被放大，SVG 图像中的文本也是可选的，同时也是可搜索的（很适合制作地图）。 WebP：谷歌开发的一种旨在加快图片加载速度的图片格式，WebP 为网络图片提供了无损和有损压缩能力，同时在有损条件下支持透明通道。据官方实验显示：无损 WebP 相比 PNG 减少 26%大小；有损 WebP 在相同的 SSIM（Structural Similarity Index，结构相似性）下相比 JPG/JPEG 减少 25%~34%的大小；有损 WebP 也支持透明通道，大小通常约为对应 PNG 的 1/3。支持动图能力，并且也占用更小空间，更适应移动网络的动图播放。但是好东西兼容性往往都不好。 Base64：一种基于 64 个可打印字符来表示二进制数据的方法。实际上是一种“二进制到文本”的编码方法，它能够将给定的任意二进制数据转换（映射）为 ASCII 字符串的形式，以便在只支持文本的环境中也能够顺利地传输二进制数据。 BPG： 是一个新的图片格式。用来代替 jpeg 和 webp 的方案，缺点–浏览器对其的支持程度是非常低的，目前还没有大范围使用 优势 压缩比高。对于类似的质量，文件比 JPEG 小得多。 支持与 JPEG（灰度，YCbCr 4：2：0,4：2：2,4：4：4）相同的色度格式，以减少转换过程中的损耗。支持 Alpha 通道。还支持 RGB，YCgCo 和 CMYK 颜色空间。 支持无损压缩。 可以包括各种元数据（例如 EXIF，ICC 配置文件，XMP）。 动画支持。 相近画质前提下比 webp 更小性能。 据 mozilla 的研究，bpg 使用的 HEVC 编码比原生的 HEVC 性能更好，因为 BPG 的头部比 HEVC 的头部更小。 BPG 可以用于硬件上支持 HEVC 编解码器这种图片格式目前还没有被浏览器支持，需要 JavaScript 解码，但其优势非常明显。 优化方法：图片懒加载 图片懒加载是现在最常用的性能优化手段之一，对于首屏用不到的图片，我们完全可以使用懒加载在用户下拉到对应位置的时候再进行加载，避免网页打开时一下子加载过多资源。 图片渐进显示 JPEG 还可以细分为 Baseline JPEG（标准型）、Progressive JPEG（渐进式）。 Baseline JPEG 格式： Progressive JPEG（渐进式）：使用了渐进显示 使用 Progressive JPEG 格式图片，直接使用 Photoshop，然后在保存为 JPEG 格式的时候，将连续这个选项勾选即可。 缓存优化CDN 缓存CDN 的全称是 Content Delivery Network，即内容分发网络，基本原理是避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容能够传输的更快，更加稳定。 原理：通过在各个地方部署相应的服务器，形成 CDN 集群，从而提高访问速度。 客户端在获得 IP 地址之后，访问最近的边缘节点。边缘节点是最小的，规模也是最小的，不会缓存所有东西。如果没有找到对应资源就会去它的上一层区域节点去寻找，如果依然没有则去中心节点寻找，如果中心节点也没有，最后再去原网站去访问。这一层一层向上找的过程我们称为回源。 优化方案： 使用第三方的 CDN 服务不妨也是一个好的选择。 CDN 进行静态资源缓存 直播传送 本地缓存LocalStorage优势 大小方面相比，LocalStorage 突破了 4KB 大小体积限制，一般是 5MB(不同的浏览器大小有所区别)，这相当于一个 5MB 大小的数据库提供给我们来使用，我们可以存储更多信息，这方面我们可以有更多的想象； LocalStorage 是持久存储，它并不会随着页面的关闭而消失，除非我们主动去清理，不然它会一直在本地，不会过期； 仅仅存储于本地，不会像 Cookie 那样，每次的 HTTP 请求都会携带。 劣势 浏览器兼容性问题，IE 只有在 IE8 以上的版本才会支持； 如果浏览器设置为隐私模式，那么我们无法读取 LocalStorage； LocalStorage 受同源策略的限制，即协议、端口、主机地址有任何一个不同，则无法访问。 SessionStorageSessionStorage 只在当前会话下才会起作用，一旦我们关闭当前的 Tab，SessionStorage 也就失效了。因此，SessionStorage 是一个有时效性的存储方案。 使用场景：由于 SessionStorage 具有时效性，常用的业务场景比如网站常见的游客登录，就可以存储在 SessionStorage 当中，还有网站的一些临时浏览记录都可以使用 SessionStorage 来进行记录。 CookieCookie 的大小最大只有 4KB，而且它是纯文本的文件，我们每次发起 HTTP 请求都会携带 Cookie。 特性 Cookie 一旦创建成功，那么名字无法进行修改； Cookie 无法跨域名，这是由 Cookie 隐私安全性所决定的，这样能够阻止非法获取其它网站的 Cookie； 每个单独的域名下面的 Cookie 数量不能超过 20 个。 IndexedDBIndexedDB 是非关系型数据库(类 NOSQL)，其实它和我们当下非常流行的 MongoDB 非常相似，我们直接使用 JavaScript 语言就可以直接进行相关的操作，不需要别的语言，大大降低了学习成本。 合理利用缓存是前端工程师的必修课 HTTP 缓存策略在概念层面 HTTP 缓存策略又细分为强制缓存和协商缓存 最完美的效果就是我们发起请求然后取到相应的静态资源。如果服务端的静态资源没有更新，我们就下次访问的时候直接从本地读取即可；如果服务端的静态资源已经更新，那么我们再次请求的时候就要到服务器请求最新的资源，然后进行拉取。 强制缓存强缓存直接从缓存数据库中取出资源，无需再发送请求到服务器上 *expires * expires 是 HTTP1.0 的字段，通过指定一个具体的绝对时间值作为缓存资源的过期时间 Cache-Control Cache-Control 是 HTTP1.1 才有的字段，Cache-Control 设置的是一个相对时间，单位是秒，可以更加精准地控制资源缓存 Cache-Control 可设置的字段值较多，下面我们一一来介绍。 public：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制； private：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的 HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存； no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源； no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源； max-age=：设置缓存的最大有效期，单位为秒； s-maxage=：优先级高于 max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头； max-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。 上面就是强制缓存的常用字段，实际开发当中 expires 和 Cache-Control 一般都要进行设置，这是为了兼容不支持 HTTP1.1 的环境。两者同时存在，Cache-Control 的优先级要高于 expires。 强缓存状态码为200 from memory cache（缓存资源在内存中） from disk cache（缓存资源在硬盘中） 协商缓存对比缓存是需要经过服务器确认是否使用缓存的机制，其 http 状态码为304，意为not modified。 如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。 Last-Modified/If-Modified-Since 最后一次的修改时间，设置方法和我们上面讲的强制缓存的设置方法一样，都是设置一个时间戳，同样它也是由服务端放到 Response Headers 返回给我们 如果有设置协商缓存，我们在首次请求的时候，返回的 Response Headers 会带有 Last-Modified。当再次请求没有命中强制缓存的时候，这个时候我们的 Request Headers 就会携带 If-Modified-Since 字段，它的值就是我们第一次请求返回给我们的 Last-Modified 值。服务端接收到资源请求之后，根据 If-Modified-Since 的字段值和服务端资源最后的修改时间是否一致来判断资源是否有修改。如果没有修改，则返回的状态码为 304；如果有修改，则返回新的资源，状态码为 200。 缺陷 服务端对 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在 1 秒钟以内被修改多次的话，这个时候服务端无法准确标注文件的修改时间。 服务端有时候会定期生成一些文件，有时候文件的内容并没有任何变化，但这个时候 Last-Modified 会发生改变，导致文件无法使用缓存。 Etag/If-None-Match 通常是根据文件的具体内容计算出一个 hash 值，只要文件的内容不变，它就不会发生改变，保证了唯一性，这一点可以类比人的指纹。 如果我们有设置协商缓存，在首次请求的时候，返回的 Response Headers 会带有 Etag 值。当再次请求没有命中强制缓存的时候，这个时候我们的 Request Headers 就会携带 If-None-Match 字段，它的值就是我们第一次请求返回给我们的 Etag 值。服务端再用 Etag 来进行比较，如果相同就直接使用缓存，如果不同再从服务端拉取新的资源。 nginx 缓存配置 expires 和 cache-control 打开 Nginx 的配置文件 nginx.conf 12345678910// expires:给图片设置过期时间30天，这里也可以设置其它类型文件location ~ \\.(gif|jpg|jpeg|png)$ &#123; root /var/www/img/; expires 30d;&#125;// cache-control:给图片设置过期时间36秒，这里也可以设置其它类型文件location ~ \\.(gif|jpg|jpeg|png)$ &#123; root /var/www/img/; add_header Cache-Control max-age=3600;&#125; Last-Modified 和 Etag Last-Modified 在 Nginx 当中是默认启用的。 Etag 需要单独配置 需要先安装 Etag 模块；安装成功之后，仍然打开 nginx.conf 文件，确保当中没有出现 etgoff，然后添加如下配置，即可开启 Etag： 1234location ~ .*\\.(gif|jpg|jpeg|png)$ &#123; FileETag on; etag_format \"%X%X%X\"; //这里格式化规则可以修改 &#125; webpack 打包缓存配置12345678910111213141516171819202122232425262728293031323334353637module.exports = &#123; entry: &#123; index: './test/test.js', about： './test/about.js' &#125;, output: &#123; // 打包出来的JavaScript文件用chunkhash filename: '[name].[chunkhash:8].js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [&#123;loader: MiniCssExtractPlugin.loader&#125;,'css-loader'] &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'file-loader', query: &#123; // 图片文件使用hash name: '[name].[ext]?[hash]', outputPath: 'static/img/', publicPath: '/dist/static/img/' &#125; &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new MiniCssExtractPlugin(&#123; // 抽离的CSS文件用contenthash filename: '[name].[contenthash:8].css', chunkFilename: '[id].css' &#125;), ]&#125; 渲染与性能优化浏览器的渲染引擎 IE（Trident） Chrome（Blink） Firefox（Gecko） Opera（Blink） Safari（Webkit） UC（U3） QQ 浏览器微信（X5/Blink） 解析 HTML 和解析 CSS 是并行处理的，如果遇到 &lt;script&gt;标签会停止解析，先执行标签当中 JavaScript；如果是外联方式，也需要等待下载并且执行完对应的 JavaScript 代码，然后才能够继续执行解析 HTML 的工作。 针对渲染原理进行相关优化css 优化CSS 解析和 HTML 解析是同步进行的，那么一个 HTML 文档首先解析的肯定是 HTML，然后才是 CSS，这就导致了 HTML 解析完成后，往往需要等待 CSS 解析。如果 CSS 没有解析完成，我们就需要一直等，这里就是 CSS 阻塞了相关的渲染。因此针对这种情况，我们往往把 CSS 样式表全部通过 &lt;style&gt; 标签内联到网页当中 js 优化JavaScript 既会阻塞 HTML 解析，也会阻塞 CSS 解析。因此我们可以改变 JavaScript 的加载方式或者加载时机来进行优化： 尽量将 JavaScript 文件放在 body 的底部； body 中间尽量不要写 &lt;script&gt; 标签； 我们都知道通过 &lt;script&gt; 标签引入 JavaScript 代码的方式共有 3 种，一个就是直接引入，另外两种分别用添加 async 属性和 defer 属性的方式引入。如果设置为 defer，那么整个 JavaScript 的加载是异步的，并且在 DOMContentLoaded 事件之后才会执行当中的代码；如果设置为 async，整个 JavaScript 的加载是异步的，但是不会阻塞浏览器的任何操作，加载完成后执行相关代码。所以这里的最佳实践是 async 执行时机不确定，不建议用于业务代码，但可用于单独的代码，如第三方统计代码。而 defer 是在 DOMContentLoaded 事件之后执行，所以 defer 一般用于业务代码。 首屏空白优化随着 React、Vue 等框架的流行，SPA 应用越来越多，由于 SPA 应用打包生成的 JavaScript 文件非常大，首屏都是等这个巨大的 JavaScript 文件加载完成之后，才能够开始渲染，这就导致首屏加载必然会出现白屏问题。 骨架屏骨架屏就是我们页面在未完成加载的时候，先用一些简单图形大概勾勒出整个页面，给用户视觉上更好的体验，而不是整个页面都是白屏。等到资源加载完毕，再把骨架屏替换掉即可。整个过程我们用一张图来表示就非常容易理解 目前使用比较广泛的是 page-skeleton-webpack-plugin 这个插件，它是一个 Webpack 插件，可以根据具体的页面生成对应的骨架屏。具体的配置方案这里写得非常详细，这里不再详细罗列，而且它支持动态调试，对于多个页面的使用非常方便。 使用 Code Splitting代码分割（Code Splitting）是指将项目代码构建打包（Bundling）后，根据指定规则分割成多个 bundles（输出文件），这些模块文件可以被按需动态加载或者并行加载，可以用来优化代码加载时的资源大小及优先级。正确使用代码分割，可以优化提升资源加载效率。 使用按需加载。按需加载的方案非常多，最常用的就是使用 ES6 新增的 import() 方法。使用方法也非常简单，我们只需要在我们的路由文件当中引入即可，如下： 1234567891011const Test1 = () =&gt; import( /* webpackChunkName: \"Test1\" */ \"./pages/Test1.vue\" );const Test2 = () =&gt; import( /* webpackChunkName: \"Test2\" */ \"./pages/Test2.vue\" ); 这里 Webpack 配置的输出也要做对应的修改，如下： 12345module.exports = &#123; output: &#123; chunkFilename: \"[name].chunk.js\", &#125;,&#125;; 使用资源预加载简单来说就是在当前页面加载完成后或者其它空闲时间，我们可以加载下面页面会用到的资源。 12&lt;link rel=\"preload\" href=\"style.css\" as=\"style\"&gt;&lt;link rel=\"preload\" href=\"main.js\" as=\"script\"&gt; 我们预加载了 CSS 和 JavaScript 文件。所以在随后的页面渲染中，一旦需要使用它们，它们就会立即可用。 DOM 的优化在日常开发当中，不管我们是否使用框架，书写 HTML 是不可避免的，并且操作 DOM 是非常耗费性能的，如果操作错误还会引起回流。 注意语义化：有利于浏览器解析时间，而且对搜索引擎的抓取也是十分友好的。 尽量减少无用的标签：不要嵌套多个无用的 div，对一下没有用的 div 要及时删除，能用 CSS 实现的，尽量不要使用相关的 HTML 元素。 重绘与回流回流：当有元素的大小、布局、结构等发生改变时，就会触发回流，每个页面在首次加载的时候都需要进行至少一次回流。 重绘：有元素属性需要更新，这些属性只是影响元素的外观、风格，那么则会触发重绘。 如何减少重绘与回流 避免使用表格布局方法 减少触发它们操作的次数 把相关的属性的缓存起来，然后最后在对其进行处理 修改样式的时候使用类名的方式一次性进行修改，而不是使用 style 的方式 对一些涉及到复杂动画的元素，在不影响相关布局的情况下，尽量将其 position 属性设置为 absolute 或者 fixed Event LoopJavaScript 是单线程的语言，它在一个时间点只能处理一件事情，完成一件事情之后才可以继续另外一件事情。JavaScript 为了解决这个问题，于是产生了使用异步这种方式来模拟多线程，而支撑异步的就是 Event Loop。 heap heap 是堆这种数据结构，堆其实就是我们平时所说的二叉树，这里存放的主要是 JavaScript 当中的对象，也是 Event Loop 当中一个重要的环节。 stack 栈，后进先出，代码执行的时候，会将代码压入栈中进行执行，当任务完成之后，根据栈后进先出的特点，再将各个任务进行出栈。 假定没有异步任务的情况下 JavaScript 的执行顺序，当我们遇到异步任务，比如：setTimeout、addEventListener 这类异步任务的时候，这个时候异步任务不会直接被压入到栈中，而是会交给浏览器的 Web API 进行维护，当这些异步任务执行完成之后，会在任务队列当中放置对应事件。当执行栈当中任务为空的时候，然后浏览器读取任务队列，再把对应的异步任务压入到执行栈执行，这就是我们经常说的事件循环。 Macrotask/Microtask 任务队列 Microtask 优先级是高于 Macrotask 的，Microtask 当中任务不会一个一个压入执行栈，而是所有任务直接压入栈中，当 Microtask 当中的任务执行完毕后，然后我们再从 Macrotask 中取栈顶的第一个任务进行执行。 那么哪些任务属于 Microtask，哪些任务属于 Macrotask 呢，这里我做了一个大概的总结，如下： Macrotask：setTimeout、setInterval、I/O、UI Rendering、script当中的所有代码、setImmediate(Node) Microtask：process.nextTick(node) 、Promise 、MutationObserver 优化方法 当开始执行的时候，首先 script 标签当中的代码出 Macrotask，被压入到执行栈执行，这个时候就会有对应的任务被推入 Macrotask 和 Microtask 当中，上面我们已经说过 Microtask 是所有任务一起执行，而 Macrotask 则是任务一个一个执行，那么页面渲染是在 Microtask 之后才进行的，如果我们在异步操作当中进行 DOM 操作，我们尽量将这个操作用 Microtask 当中的任务包一下，这样我们就可以在页面渲染之前就执行这个 DOM 操作了。 防抖节流点击这里可以体验防抖和节流的效果 节流(throttle)不管你在一段时间内如何不停地触发事件，只要设置了节流，就会每隔一段时间执行一次 12345678//防抖const debounce = (() =&gt; &#123; let timeout; return (callback, wait) =&gt; &#123; if (timeout) clearTimeout(timeout); timeout = setTimeout(callback, wait); &#125;;&#125;)(); 防抖(debounce)防抖的原理则是不管你在一段时间内如何不停的触发事件，只要设置了防抖，则只在触发 n 秒后才执行。 12345678// 防抖const debounce = (() =&gt; &#123; let timer = 0; return (callback, wait) =&gt; &#123; clearTimeout(timer); timer = setTimeout(callback, wait); &#125;;&#125;)(); 服务端渲染 服务端渲染在一般场景下其实是无需使用的，虽然它可以解决白屏问题以及 SEO 优化，但是它对服务端要求非常高 客户端渲染(CSR) 页面初始加载的 HTML 文档中无内容，需要下载执行 JS 文件，由浏览器动态生成页面，并通过 JavaScript 进行页面交互事件与状态管理，这样的页面渲染采用的就是客户端渲染。 服务端渲染(SSR) 在服务器端执行一次，用于实现服务器端渲染（首屏直出）；在客户端再执行一次，用于接管页面交互。这样页面渲染采用的就是服务端渲染。 本地离线渲染(NSR) 通过离线资源和预加载的方式，native 提前完成渲染页面并放入缓存，等用户点击的时候瞬间呈现页面","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://superliebe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://superliebe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2020-07-27T01:49:59.000Z","updated":"2020-08-01T04:15:12.345Z","comments":true,"path":"2020/07/27/数据结构与算法/","link":"","permalink":"http://superliebe.github.io/2020/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","excerpt":"数据结构：数组，链表，栈和队列，散列表，字典，集合，堆，树，图 算法：冒泡排序，选择排序，快速排序，插入排序，计数排序，基数排序，归并排序，桶排序，堆排序，搜索，动态规划，贪心算法，回溯算法","text":"数据结构：数组，链表，栈和队列，散列表，字典，集合，堆，树，图 算法：冒泡排序，选择排序，快速排序，插入排序，计数排序，基数排序，归并排序，桶排序，堆排序，搜索，动态规划，贪心算法，回溯算法 常见时间复杂度 复杂度 级别 描述 O(1)O(1) 常数级 最优，执行时间不受数据多少限制 O(log_n)O(log**n) 对数级 相当好，例如：二分查找算法 O( n )O(n) 线性级 还不错，执行时间等于元素个数 O(n log_nm)O(nlogn**m) 线性对数 还可以，比上一稍差 O(n^2)O(n2) 二次幂 有点慢，例如：双层for循环 O(n^3)O(n3) 三次幂 特别慢，例如：矩阵乘法 O(2^n)O(2n) 指数级 超级慢，添加一点数据就会将时间拖的特别长 O!O! 灾难级 奇慢无比，例如：旅行商问题 注：算法的时间复杂度是衡量一个算法好坏的重要指标。 数据结构数组数组是属于线性结构，是顺序存储数据的结构 数组的优劣和操作的时间复杂度 优点：更新查找快，由于数组是线性查存储，所以我们只需要给到我们想要的元素下标，就可以方便的更新元素和查找元素。 缺点：增删慢，还是因为数组的线性存储，举个比较简单的例子，比如说我们的书桌上堆放着一摞书，我想要拿第 5 本，我需要动前 4 本才可以拿到想要的。如果书我想把一本书放在中间位置，同样需要动中间位置之前的所有书才可以。” 时间复杂度：由于更新查找的时候只需要提供下标，所以时间复杂度是O(1)。增加和删除的时候需要改动数组中的其他元素，所以时间复杂度是O(n)。 例：如何乱序数组 1arr.sort((a,b)=&gt; Math.random()&gt;.5?-1:1) 链表 链表是线性结构； 链表的存储方式是不连续的，是将零散的内存块串联起来； 每个内存块成为节点 Node，除了存储数据，还需要存储指向下一个内存块的指针； 存储方式为：以 head 为头节点，头结点可以不存放任何数据，它是链表的开始，指向链表中第一个节点，而每个节点都有一个 next 的向下引用，指向下一个节点，直到最后一个节点。每一个节点由两部分组成，包括 data（存放数据），next（指向下一个节点）。 常见链表分为以下几种： 单向链表 单向循环链表 双向列表 双向循环列表 js链表数据图 链表中的环是什么 链表中 5 这个节点的后继指针指向了 3 这个节点，所以在 3，4，5 这个区间内形成了一个环状链表。于循环链表不同的是环节点并不是首元结点，所以只能说这个链表中有环，但是不能说这是个循环链表。 如何判断是否存在环 定义两个指针从头节点开始遍历链表，如果两个指针有相遇，则说明链表中有环 123456789101112function judge(list)&#123; let fast = list.next.next; // 快指针，每次走两步 let slow = list.next; // 慢指针，每次走一步 while(list)&#123; if(fast === slow) &#123; // 如果快慢指针相遇，表示有环2 return true; &#125; fast = fast.next.next; slow = slow.next; &#125; return false;&#125; 栈和队列栈和队列是计算机科学中使用的比较广泛的两种数据结构，如：程序的递归是使用栈来实现的，操作系统中进程调度网络管理中的打印服务等都是通过队列来实现的。 栈–先入后出 又叫堆栈 受限操作：限定只能在表尾进行增加和删除操作。可进行操作的一端成为 栈顶 。不可操作的一端成为 栈底 。 增加元素的操作又称为进栈、入栈或者压栈。意思是把元素添加到栈顶的位置。 删除元素的操作又称为出栈或者退栈。意思是把元素从栈顶移除。使其相邻元素成为栈顶元素。 队列–先入先出 受限操作：限定只能在表的前端进行删除操作，只能在表的后端进行插入操作。 进行插入操作的一端称为队尾，进行删除操作的一端称为队头。 增加元素的操作称为入队列 ，意思是把元素添加到队尾的位置。 删除元素的操作称为出队列 ，意思是把元素从队头位置移除。 栈溢出 栈溢出一般指的是，我们定义的数据所需要占用的内存超过了栈的大小时，就会发生栈溢出 解决方案：尾递归优化 函数在最后一步调用其他函数，称为尾调用。 队列溢出 真溢出 指的是由于存储空间不够而产生的溢出叫真溢出； 解决方式：扩容的方式解决。 假溢出 队列中尚余有足够的空间，但元素却不能入队。一般是由于队列的存储结构或操作方式的选择不当所致。 解决方式:删除元素后将所有元素向前移动一位。 未完待续…","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://superliebe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://superliebe.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"typescript未来可期","slug":"typescript文档","date":"2020-07-24T02:11:01.000Z","updated":"2020-07-24T08:28:09.133Z","comments":true,"path":"2020/07/24/typescript文档/","link":"","permalink":"http://superliebe.github.io/2020/07/24/typescript%E6%96%87%E6%A1%A3/","excerpt":"vue3源码采用了大量ts的写法，掌握ts技巧也是前端进阶的必经之路，肝起来~","text":"vue3源码采用了大量ts的写法，掌握ts技巧也是前端进阶的必经之路，肝起来~ 介绍特点 JavaScript 的超集 增加了静态类型系统 为大型软件开发而设计的 最终编译产生 JavaScript 安装全局安装typetypescript 1cnpm install -g typescript 安装成功后使用 tsc -v 查看版本号 编译过程 在后缀名为.ts的文件中编写typescript代码 使用tsc 将ts文件编译成js代码 在浏览器中执行或者node中执行 vscode 自动编译点击菜单 终端-运行任务或者在vscode中按 Ctrl + Shift + B，每次保存后就会自动编译成对应的js文件 ts基础语法变量指定类型后，该值只能是类型的值。 12345678// let 变量名:变量类型 = 值;let name1:string=\"张三\";//如果不定义：string，ts会自动根据值来判断类型let name2=\"张三\";//等价于 let name2:string=\"张三\";//联合类型let name3:string|number = \"哈哈\" 常见类型 原有类型 string、number、 boolean、array、object、null、undefined、symbol 新增类型 tuple 元组、enum 枚举 、any 任意类型、never、void 数组元素类型固定 12345// 方式一：let 数组名：类型[] =[值] let arr1:string[] = [\"jake\",\"lilei\"]//方式二：let 数组名：Array&lt;类型&gt;=[值] let arr2:Array&lt;string&gt; = [\"jake\",\"lilei\"] 元组就是一个规定了 元素数量和元素类型的数组，而每个元素的类型可以不一样 12// let 元组名:[类型1,类型2,类型2] = [值1，值2，值2]let arr1:[string,number,boolean]=[\"啦啦\",10,true] 枚举12345678910111213141516171819202122/*enum 枚举名&#123; 枚举项1=枚举值1， 枚举项2=枚举值2， ...&#125;枚举项一般用英文，枚举值一般用数字，如果不写枚举值，默认赋值对应的下标0,1,2...*/enum person&#123; man:1, woman:2, saiban:3,&#125; enum person2&#123; man,//--&gt;0 woman,//--&gt;1 saiban,//--&gt;2&#125; //取值let usersex:person = person.man; 其他数据类型 any ：any代表任意类型，一般在获取dom时使用 1let dom:any = document.getElementById(\"app\") void：void 代表没有类型，一版用在无返回值函数。 1234567891011//有返回值function say1():string&#123; return \"hello string\"&#125;let ref1= say1();//无返回值function say2():void&#123; console.log(\"hello void\")&#125;say2(); never：代表不存在的值的类型，常用作抛出异常或者无限循环的函数返回类型 123456789function test():never&#123; while(true)&#123; //无限循环 &#125;&#125;function test2():never&#123; throw new Error(\"hello never\")&#125; 补充：never类型是ts中的底部类型，所有类型都是never类型的子类，所以never类型的值可以赋值给任意类型的变量 函数特点：实参和形参类型必须保持一致 1234567891011121314151617181920function 函数名(形参1:类型,形参2:类型):返回值类型&#123; &#125;let 变量名：变量类型 = 函数名(实参1,实参2)//可选参数，可传可不传function 函数名(形参1?:类型,形参2?:类型):返回值类型&#123; &#125;//默认参数，不传则使用默认值，如果想要第一个默认，第二个传参则 第一个传undefined即可function 函数名(形参1:类型=默认值1,形参2:类型=默认值1):返回值类型&#123; &#125;//剩余参数,只能定义一个，只能定义为数组，只能写在最后function 函数名(形参1:类型,形参2:类型，...形参3:类型3[]):返回值类型&#123; &#125; 类12345678910111213141516171819class City&#123; //成员变量定义在类中 cname:string=\"\"; clevel:string=\"\"; constructor(name:string,level:string)&#123; //构造函数初始化 this.cname=name; this.clevel= level &#125; //成员方法 about()&#123; console.log(`城市：$&#123;this.cname&#125;，等级$&#123;this.clevel&#125;`) &#125; &#125;let c1 = new City(\"p1\",\"一级\")","categories":[{"name":"typescript","slug":"typescript","permalink":"http://superliebe.github.io/categories/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://superliebe.github.io/tags/typescript/"}]},{"title":"vue3+vite初探","slug":"vue3-vite初探","date":"2020-07-20T02:29:55.000Z","updated":"2020-08-01T04:15:26.088Z","comments":true,"path":"2020/07/20/vue3-vite初探/","link":"","permalink":"http://superliebe.github.io/2020/07/20/vue3-vite%E5%88%9D%E6%8E%A2/","excerpt":"","text":"vue3.0的特性 按需加载 &amp; 组合api TS支持，新增 Fragment（碎片）、Teleport（全局组件）、Suspense(异步加载) 性能提升 1.3 ~ 2 倍 基于Proxyx下，去掉属性的定义，根据拦截直接get返回对应结果，性能得到提升 更新的时候，只需要更新动态的节点，与静态节点解耦，性能得到提升 vue3 常用api官网已经讲解的很详细了，这里略过😝 composition api 官方介绍 vue3 API 手册 vite介绍vite（快的意思），是一个http服务器 可以在单文件中书写es6语法； 支持热更新（请求的内容才会被打包更新）； Rollup打包； vue-cli版本一定要是最新的，否则容易报错 vite 和 webpack的区别 功能 vite webpack 启动速度 快 （不需要提前编译、打包，请求到达服务器才编译，浏览器直接支持 es moudle，最大的好处是引用多少编译多少） 慢（需要先编译build到内存中，发送到服务器的代码需要require模式） 打包 使用 rollup打包，加载时使用原生 es import 将所有模块打包成一个或多个 bundle 内置热加载 react-fast-refresh插件（速度几乎瞬间） 无（速度较慢） 配置 开箱即用 需要复杂的配置 打包体积 更小 小 未完待续…","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"vite","slug":"vue/vite","permalink":"http://superliebe.github.io/categories/vue/vite/"}],"tags":[{"name":"vite","slug":"vite","permalink":"http://superliebe.github.io/tags/vite/"}]},{"title":"pwa渐进式webapp","slug":"pwa渐进式webapp","date":"2020-07-17T02:03:05.000Z","updated":"2020-07-21T10:02:36.414Z","comments":true,"path":"2020/07/17/pwa渐进式webapp/","link":"","permalink":"http://superliebe.github.io/2020/07/17/pwa%E6%B8%90%E8%BF%9B%E5%BC%8Fwebapp/","excerpt":"PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序， 是Google 在2016年提出的概念，2017年落地的web技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。","text":"PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序， 是Google 在2016年提出的概念，2017年落地的web技术。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验的渐进式网页应用。 pwa的优势 渐进式 - 适用于所有浏览器，因为它是以渐进式增强作为宗旨开发的。 流畅 - 能够借助 service worker 在离线或者网络不好的条件下访问。 可安装 - 用户可以添加常用的webapp到桌面上，免去去应用商店下载的麻烦。 原生体验 - 可以和app一样拥有首屏加载动画，可以隐藏地址栏等沉浸式体验。 粘性 - 通过离线通知，可以让用户回流。 manifest 应用程序清单的配置manifest是一个可配置的json文件，可以使web添加至桌面，设置启动图标，隐藏地址栏等操作 在html文件中引用配置文件 1&lt;link rel=\"manifest\" href=\"manifest.json\"&gt; 编写 manifest.json 文件 12345678910111213&#123; \"name\":\"pwa渐进式web\", \"short_name\":\"pwa\", \"icons\":[&#123; \"src\": \"./image/icon.png\", \"sizes\": \"144x144\", \"type\": \"image/png\" &#125;], \"background_color\":\"#9b59b6\", \"theme_color\":\"#34495e\", \"display\":\"standalone\", \"start_url\":\"/index.html\"&#125; manifest 属性 属性明 描述 name 用于指定应用的名称和启动画面的文字 short_name 应用的短名称，用于主屏显示 start_url 指定应用启动加载的页面 icons 指定各种环境中作为应用的图标，最佳144x144 background_color 启动动画的背景颜色 theme_color 应用程序的主题颜色 display fullscreen：全屏显示，不显示状态栏；standalone：更像一个独立的应用程序；minimal-ui：拥有地址显示栏； 浏览器中就已经可以看到配置信息了 service worker 一个标准的pwa程序必须包含3个部分 https 服务器 或者 http://localhost manifest.josn文件 service worker service worker 主要用来做持久的离线化缓存; service worker 可以极大提升webapp的用户体验; service worker 是一个独立的worker线程，独立于网页进程; 必须在https下才能正常工作; 一旦被install后必须手动unregister; 生命周期 install 注册成功时触发，主要用于缓存资源； acvitate 激活时触发，主要用于删除旧资源； fetch 发送请求时触发，主要用于操作缓存和读取网络资源； 使用方法 在window.onload中注册service worker ,防止与其他资源竞争； 老的浏览器版本不兼容，需要使用 if(&#39;serviceWorker&#39; in navigator){}； ; 注册service worker , navigator.serviceWork.register(‘./sw.js’)，返回一个promise对象； self.skipWaiting()跳过等待，返回一个promise对象； event.waitUntil() 方法的扩展参数是一个promise对象，会在promise结束后结束当前生命周期函数，防止浏览器在异步操作； service worker 激活后，会在下一次刷新页面的时候生效，可以通过self.clients.claim()立即获取控制权； 123456789101112// 页面加载完之后，注册serviceWorker window.addEventListener('load',async ()=&gt;&#123; // 检测是否可用 if('serviceWorker' in navigator)&#123; try&#123; const registration = await navigator.serviceWorker.register('./sw.js'); console.log(\"注册成功\",registration) &#125;catch(e)&#123; console.log(\"注册失败\",e) &#125; &#125; &#125;); sw.js 这三个写法基本固定 123456789101112131415161718192021//注册self.addEventListener('install', event =&gt; &#123; console.log('----install-----') console.log(event) //self.skipWaiting 会让service worker 跳过等待直接进入activate //event.waitUntil 等待skipWaiting 结束后才进入activate event.waitUntil(self.skipWaiting()) &#125;);//激活self.addEventListener('activate', event =&gt; &#123; console.log('----activate-----') console.log(event) //service worker 激活后，立即获取控制权 event.waitUntil(self.clients.claim());&#125;);//拦截请求self.addEventListener('fetch',event =&gt; &#123; //可以抓取到所有网络请求 console.log('----fetch-----') console.log( event)&#125;); 刷新浏览器就可以看到控制台上相应生命周期输出的结果 fetch api类似于ajax，专门用于service worker 中请求数据使用 fetch(url,config) 1234567fetch(\"/api/...\").then(res=&gt;&#123; //res得到的事响应式内容，是一个二进制流 //调用res.json 可以把数据转化为可读的json格式 return res.json()&#125;).then(data=&gt;&#123; console.log(data)&#125;) notification 通知通过推送告诉用户某信息，比如断网/联网的时候要通知到用户，提升用户体验。 Notification.permission 可以获取到当前用户通知 的权限 defalut 默认，未授权 denied 拒绝授权，无法再次请求授权，无法弹出窗口 granted 通过授权 Notification.requestPremission() 可以请求用户授权。 new Notification(‘提示的标题’,{body:’提示的内容’,icon:’提示的图标’}) 可以显示通知。 123456789101112131415//如果一进来我们发现用户没有联网就给用户一个通知if(Notification.permission=='defalut')&#123; //授权开启通知 Notification.requestPermission();&#125;if(!navigator.onLine)&#123; //断网 console.log(\"断网\") new Notification(\"提示\",&#123;body:'网络已断开,您访问的是缓存',icon:'/image/icon.png'&#125;)&#125;window.addEventListener(\"online\",()=&gt;&#123; console.log(\"网络已连接\") new Notification(\"提示\",&#123;body:'网络已连接，请刷新页面获取新的数据',icon:'/image/icon.png'&#125;)&#125;) cache storage配合service worker 来实现缓存 caches.api 常用方法 caches.open(cachesName).then(res=&gt;{}) 用户打开一个缓存，返回一个匹配cachesNam的catch对象promise，类似于链接数据库操作； caches.keys() 返回一个promise对象，包括所有缓存的key (数据库名) ； caches.delete(key) 根据key删除对应的缓存； cache 常用方法（单条数据操作） cache.put(req,res) 把请求当key，并把对应的相应存储起来； cache.add(url) 根据url发起请求，并把相应结果存储起来； cache.addAll(url) 抓取一个url数组，并把结果都存起来； cache.match(req) 获取req对应的response； 通过caches api 来实现读取离线缓存 html中引入对应的资源文件，在页面加载完之后，注册serviceWorker。 sw.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//注册,主要缓存内容const CACHE_NAME = 'cache_3'; //定义存储缓存的名字--类似数据库const CACHE_URL = [ '/', '/image/icon.png', '/manifest.json', '/index.css']self.addEventListener('install', async event =&gt; &#123; //开启cache缓存，类似连接数据库 const cache = await caches.open(CACHE_NAME); //cache 添加需要缓存的资源,使用await 等待把所有缓存存起来再进行 await cache.addAll(CACHE_URL) //跳过等待直接进入activate await self.skipWaiting();&#125;);//激活，主要清除缓存self.addEventListener('activate', async event =&gt; &#123; //获取到左右资源的key const keys = await caches.keys() keys.forEach(key =&gt; &#123; if (key != CACHE_NAME) &#123; //旧资源 caches.delete(key) &#125; &#125;) //service worker 激活后，立即获取控制权 await self.clients.claim();&#125;);//监听请求，判断资源是否能够请求成功，成功则取相应结果，断网则取缓存内容self.addEventListener('fetch', async event =&gt; &#123; //请求对象 const req = event.request; //只缓存同源内容 const url = new URL(req.url); if (url.origin !== location.origin) &#123; return &#125; //给浏览器相应, if (req.url.includes(\"/api\")) &#123; //资源走网络优先 event.respondWith(networkFirst(req)) &#125; else &#123; //资源走缓存优先 event.respondWith(cacheFrist(req)) &#125;&#125;);//网络优先async function networkFirst(req) &#123; //取缓存中读取 const cache = await caches.open(CACHE_NAME); //先从网络获取资源 try &#123; const fresh = await fetch(req); //获取到的数据应该再次更新到缓存当中，把响应的备份存到缓存当中 cache.put(req,fresh.clone()) return fresh &#125; catch (e) &#123; //匹配与req对应的资源 const cached = await cache.match(req); return cached &#125;&#125;//缓存优先async function cacheFrist(req) &#123; //打开缓存 const cache = await caches.open(CACHE_NAME); //取出对应数据 const cached = await cache.match(req) if (cached) &#123; //如果从缓存中得到了，直接返回缓存 return cached &#125; else &#123; const fresh = await fetch(req); return fresh &#125;&#125; 打开控制台，application中即可看到被缓存的文件。 勾选network中的 offline online来关闭网络， 刷新页面会发现，即使断网的情况洗也可以访问到正常的数据。","categories":[{"name":"pwa","slug":"pwa","permalink":"http://superliebe.github.io/categories/pwa/"}],"tags":[{"name":"pwa","slug":"pwa","permalink":"http://superliebe.github.io/tags/pwa/"}]},{"title":"docker镜像发布到dockerhub和阿里云","slug":"docker镜像发布","date":"2020-07-11T13:27:07.000Z","updated":"2020-07-13T03:16:52.054Z","comments":true,"path":"2020/07/11/docker镜像发布/","link":"","permalink":"http://superliebe.github.io/2020/07/11/docker%E9%95%9C%E5%83%8F%E5%8F%91%E5%B8%83/","excerpt":"docker 镜像发布，一般使用以下两种情况","text":"docker 镜像发布，一般使用以下两种情况 发布前准备 创建自己的 dockerhub 账号，dockerhub 官网。 在服务器上提交镜像。 docker 镜像发布到 dockerhub 首先登录 dockerhub 123docker login -u 用户名#然后输入密码，提示登录成功 登陆完毕后就可以提交镜像了。 123docker push 作者名/镜像名:版本号# 如果当前版本为latest，需要使用 docker tag 镜像id 1.0 修改版本号 提交的时候也是按照镜像层级来提交的 docker 镜像发布到 阿里云 登陆阿里云 找到容器镜像服务 创建命名空间 创建镜像仓库 点击管理，可以查看详细的操作步骤,按照操作提示来登录，推送景象即可","categories":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"}]},{"title":"dockefile的使用","slug":"dockerfile的使用","date":"2020-07-09T13:54:49.000Z","updated":"2020-07-11T13:26:46.927Z","comments":true,"path":"2020/07/09/dockerfile的使用/","link":"","permalink":"http://superliebe.github.io/2020/07/09/dockerfile%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"docker 是用来构建 docker 镜像文件，命令参数的脚本。 构建步骤 编写一个 dockerfile 文件。 docker build 构建成为一个镜像。 docker run 运行镜像。 docker push 发布镜像（dockerhub , 阿里云仓库）。 很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！ dockerfile 的构建过程基础知识 每个指令都必须是大写字母。 执行从上到下顺序执行。 #表示注释 每个指令都会创建一个新的镜像层并提交。 docker 镜像逐渐成为企业交付的标准，所以你懂的。 DockerFile: 构建文件，定义了一切的步骤，源代码 DockerImages : 通过 DockerFile 构建生成的镜像，最终发布和运行的产品！ Docker 容器 : 容器就是镜像运行起来提供服务 dockerfile 指令123456789101112FROM #基础镜像，一切从这里开始构建MAINTAINER (maintainer) #镜像是谁写的，姓名+邮箱RUN #镜像构建的时候需要运行的命令ADD #添加内容，如添加一个tomcat的压缩包WORKDIR #镜像的工作目录VOLUME #挂载的目录EXPOST #暴露端口配置CMD #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代！ENTRYPOINT (entrypoint) #指定这个容器启动的时候要运行的命令，可以追加命令！ONBUILD #当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令，触发指令！COPY # 类似ADD ，将文件拷贝到镜像中！ENV # 构建的时候设置环境变量！ 实战测试Docker Hub 中 99% 的镜像都是从 FROM scratch 这个基础镜像过来的！然后配置需要的软件和配置来进行构建 创建一个自己的centos 在 home 目录中创建 dockerfile 文件夹，vim mydockerfile ,编写dockerfile文件 123456789101112131415161718192021# 编写dockersfile文件#基于centos基础环境FROM centosMAINTAINER superkm&lt;583902049@qq.com&gt;# 设置环境变量ENV MYPATH /user/local #默认进入的目录WORKDIR $MYPATH# 执行安装的一些命令RUN yum -y install vimRUN yum -y install net-tools#暴漏的端口EXPOSE 80#输出信息，默认进入命令行CMD echo $MYPATHCMD echo \"---end---\"CMD /bin/bash 构建镜像 1234567docker build -f mydockerfile -t mycentos:0.1 .# -f dockerfile脚本文件# -t 生成目标镜像且生成到当前目录下，注意最后有个 .# 构建成功的提示# Successfully built 3c490273278b# Successfully tagged mycentos:0.1 测试运行，正常使用 我们拿到一个镜像，可以研究它是怎么做的 列出镜像的变更历史 docker history 镜像id","categories":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2020-07-01T07:54:34.000Z","updated":"2020-07-01T08:06:47.279Z","comments":true,"path":"2020/07/01/git常用命令/","link":"","permalink":"http://superliebe.github.io/2020/07/01/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"","categories":[{"name":"git","slug":"git","permalink":"http://superliebe.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://superliebe.github.io/tags/git/"}]},{"title":"npm发布vue组件包（可扩展）","slug":"npm发布第一个包","date":"2020-06-29T03:23:42.000Z","updated":"2020-07-21T10:03:14.223Z","comments":true,"path":"2020/06/29/npm发布第一个包/","link":"","permalink":"http://superliebe.github.io/2020/06/29/npm%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%85/","excerpt":"😶 NPM 是随同 NodeJS 一起安装的 javascript 包管理工具，能解决 NodeJS 代码部署上的很多问题","text":"😶 NPM 是随同 NodeJS 一起安装的 javascript 包管理工具，能解决 NodeJS 代码部署上的很多问题 发布前的准备注册一个 npm 账号 前往 NPM 官网进行注册 初始化项目这里用的是webpack-simple,可以理解为精简版的vue-cli。 如果没有全局安装 vue 的话，需要先安装 1cnpm i -g @vue/cli-init 然后再初始化 vue 项目，我们要写的是一个简单的 vue 组件，不需要依赖那么多而庞大的配置，所以，这里我们用简介版本的 webapck 配置模板 1vue init webpack-simple 项目名（最好去npm官网搜一下，防止重复） 创建之后的基本目录 创建 vue 插件并发布创建组件文件夹举个例子：封装一个返回顶部的小组件 既然是封装组件，那我们在 src 下面创建一个 plugins 文件放我们的插件，但是考虑到万一要写很多个的情况，当前组件的相关文件下创建一个 returnTop 文件夹，下面创建 returnTop.vue 和 index.js 先，结构变成下面这样： 切换到当前根目录，安装依赖，启动项目 123cnpm installcnpm run dev 编写组件代码示例代码returnTop.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;template&gt; &lt;div class=\"right-return-top\"&gt; &lt;div class=\"return-top\" @click=\"returnTop\" v-show=\"topShow\"&gt; &lt;img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAAHdbkFIAAAACXBIWXMAAAsSAAALEgHS3X78AAADGUlEQVR4nO2aT2vTYBzHv0/S9aKw7rJz34E5mP6zrRmOjeFgKozBcFAZwkAc6sHrttNgUBBPA5HNi5eBsJPX1k1XT9p3UF/B+g4iadI2ydI0T9P0SfX3hZDmeZI8n9/3efL8acJ0XYefJN/cICckHEfLGR3zCWB+BqjWWSfNYHBsT/O6/diZuaSamW/KvZPCRzEBH5wnPMnp2Ck5y3SE+TiruH2ZAOTQIkKXMM03WM4onYoz5K48m/4BE6kdxOEGCc/UBVXHLQmd7bYM6/cBDmv77lMjrsaNvI7t4u/RbrCaNdDmANzBbnnwTW6MDsam3W3rDzOp3vHLku55XpBec5ioJY6hIYVV6AgIYOoBvLvDQTK6ySQDZhgc+6TkTvPsOr005U/BRl7BVsG3ux6m0RxYzSpIsl+uKmji+EKJFmBBtRc8hy+Ndi/PmMCZbaCJaj04yKBxZuC2pKa4r/HZqCsmAOEA1AgJgAAIgACmaFasqftIsL3+NMxrdmz9PrL+mw0gGoymvBFuFtqo3EuJAVjPG1PyWQDXeF4cGWI0gLVct/A/Vso1XpRGguAHWMl2C2/i8480gGc9iNdlbgg+gMVMv/CzK3P1c/r91AHx9j4XRHAATVV6hZ83nEuvD5d2iHc8AHxLqQdq2jf/VenGCxhamhEAARAAAQyT8J5QtITXgGiRATFgECoyIAYMQkUGxIBBqMiAGDAIFd9L+6DS1DQY0pAZIBs2W3vZtpdcx55pjmtbOKy1xo0ajQFABcDemO95ACDQlxA8orVADBiESqwBm4U0tgqh/t4OKzGPwHpegYQaZDZrdXBNyEzDx8t2gKvHqskasJZTIFuBe48CphHHFxMzYjIGrGT7gfeHQTNYGY8gsxPXMGjmvf8WuRHRGrCYMQOXbIF3gzu7cga3XaxAwolrHtCExDRU65EZEY0BxqsUZqtxyRb4ecM/mJ1SBbLNiO61Rxxfw3EouhZgfOYnsxpktDq1+PUnXy3ulk0jJPYJ1XolGkiaCNFEiAyIAYNQkQExYBAqMiAGDEJFBsSAQaj+bwMA/AVQMPelPAquSAAAAABJRU5ErkJggg==\" /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"ToolReturnTop\", //决定引用组件的名称 data() &#123; return &#123; scroll: 0, topShow: false, &#125;; &#125;, mounted() &#123; window.addEventListener(\"scroll\", this.scrolls); &#125;, methods: &#123; returnTop() &#123; window.scroll(0, 0); &#125;, scrolls() &#123; this.scroll = document.documentElement &amp;&amp; document.documentElement.scrollTop + document.body.scrollTop; if (this.scroll &gt; window.innerHeight / 2) &#123; this.topShow = true; &#125; else &#123; this.topShow = false; &#125; &#125;, &#125;, &#125;;&lt;/script&gt;&lt;style scoped&gt; /* 返回顶部 */ .right-return-top &#123; position: fixed; left: 0; right: 0; bottom: 20px; z-index: 9; margin: auto; &#125; /* .return-top &#123; width: 0.63rem; height: 0.63rem; z-index: 9; margin: 0 auto; background-color: #f9f9f9; box-shadow: 0 0.01rem 0.05rem 0 rgba(0, 0, 0, 0.2) !important; -webkit-box-shadow: 0 0.01rem 0.05rem 0 rgba(0, 0, 0, 0.2) !important; border-radius: 1rem; &#125; */ .return-top &#123; width: 40px; height: 40px; z-index: 9; margin: 0 auto; background-color: #f9f9f9; box-shadow: 0 0.01rem 0.05rem 0 rgba(0, 0, 0, 0.2) !important; -webkit-box-shadow: 0 0.01rem 0.05rem 0 rgba(0, 0, 0, 0.2) !important; border-radius: 1rem; -webkit-animation: show 350ms ease-out forwards 1; animation: show 350ms ease-out forwards 1; &#125; .return-top img &#123; width: 100%; height: 100%; &#125; @-webkit-keyframes show &#123; 0% &#123; -webkit-transform: rotate(0deg); &#125; 25% &#123; opacity: 0.5; -webkit-transform: rotate(-3deg) translateY(-0.2rem); &#125; 75% &#123; -webkit-transform: rotate(3deg); &#125; 100% &#123; opacity: 0.9; -webkit-transform: rotate(0deg); &#125; &#125; @keyframes show &#123; 0% &#123; transform: rotate(0deg); &#125; 25% &#123; opacity: 0.5; transform: rotate(-3deg) translateY(-0.2rem); &#125; 75% &#123; transform: rotate(3deg); &#125; 100% &#123; opacity: 0.9; transform: rotate(0deg); &#125; &#125;&lt;/style&gt; 编辑 returTop／index.js 文件，目的：将该组件作为 Vue 插件 123456789101112131415161718// sumFunction 插件对应组件的名字import returnTop from \"./returnTop\";// Vue.js 的插件应当有一个公开方法 install 。第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象// 此处注意，组件需要添加name属性，代表注册的组件名称，也可以修改成其他的returnTop.install = (Vue) =&gt; Vue.component(returnTop.name, returnTop); //注册组件// 标签的方式引入//const install = function(Vue, opts = &#123;&#125;) &#123;// Vue.component(sumFunction.name, sumFunction);//&#125;/* 支持使用标签的方式引入 Vue是全局变量时，自动install *///if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123;// install(window.Vue);//&#125;export default returnTop; 此处需要注意的是 install。 Vue 的插件必须提供一个公开方法 install，该方法会在你使用该插件，也就是 Vue.use(yourPlugin)时被调用。这样也就给 Vue 全局注入了你的所有的组件。 在src目录下创建index.js文件,用来统一管理组件 1234567891011121314151617181920212223import Vue from 'vue';import ReturnTop from './plugins/returnTop/index.js';//返回顶部// ...如果还有的话继续添加const components = [ ReturnTop,]//循环遍历注册组件，就可以向其他ui组件库那样，使用Vue.use()来全局使用const install = function (Vue, opts = &#123;&#125;) &#123; components.map(component =&gt; &#123; Vue.component(component.name, component); &#125;)&#125;/* 支持使用标签的方式引入 */if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue);&#125;export default &#123; install, ReturnTop, //在这里多写一次可以单独调用，例如：Vue.use(vueutils.ReturnTop)&#125; 修改 package.json12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"name\": \"km-vue-utils\", \"description\": \"vue常用工具合集\", \"version\": \"0.0.1\", \"author\": \"SuperKM\", \"license\": \"MIT\", // 开源协议 // 采用commonJs入口文件，如果不配置，我们在其他项目中就不用import XX from XX来引用了，只能以包名作为起点来指定相对的路径 \"main\": \"dist/index.js\", \"jsnext:main\": \"src/index.js\", // 采用es6模块化入口 \"private\": false, // 因为组件包是公用的，所以private为false \"scripts\": &#123; \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot\", \"build\": \"cross-env NODE_ENV=production webpack --progress --hide-modules\" &#125;,// 指定代码所在的仓库地址 \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/superliebe/vueTools.git\" &#125;,// 提交bug的地址 \"bugs\": &#123; \"url\": \"https://github.com/superliebe/vueTools/issues\" &#125;, // 项目官网的url \"homepage\": \"https://github.com/superliebe/vueTools\", \"keywords\": [ \"vue\", \"component\", \"tools\", \"superkm\" ], // 指定关键字 \"dependencies\": &#123; \"vue\": \"^2.5.11\" &#125;, \"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\" ], \"devDependencies\": &#123; ... &#125;&#125; 修改.gitignore因为要用 dist 文件夹，所以在.gitignore 文件中把 dist/去掉。 修改 webpack.config.js1234567891011121314151617181920212223// 原module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'build.js' &#125;...&#125;// 新const NODE_ENV = process.env.NODE_ENVmodule.exports = &#123; entry: NODE_ENV == 'development' ? './src/main.js' : './src/index.js', output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'index.js', libraryTarget: 'umd', // 指定输出格式 umdNamedDefine: true // 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define &#125;...｝ ❗ 发布 npm 之前必须做两件事情。 ❤️ - 必须 npm run build 打包一下。 ❤️ - 必须 修改 package.json 中的版本号。 发布包到 npm 已经注册过 npm 账号，首先登陆，登陆过一次之后，就可以直接发布 1234567npm login --registry http://registry.npmjs.org//适用于使用了淘宝镜像加速的//或者npm login //未采用镜像加速过 输入账号-密码-邮箱后，提示 Logged in as *** on http://registry.npmjs.org/. 就是登陆成功了 然后直接发布 1npm publish --registry http://registry.npmjs.org 发布成功后提示，前往自己的 npm 库中就可以查看到刚刚发布的 npm 包 npm 库中 如果想删除发布的包 1npm unpublish km-vuetools --force --registry http://registry.npmjs.org npm 发布中常见错误 409 Conflict npm login 或者 npm adduser 时 输入完账号密码邮箱后 提示 E409 Conflict 报错 一般因为淘宝镜像的原因 解决方案,直接 registry 镜像源 1npm login --registry http://registry.npmjs.org npm ERR! 403 可能是包名已经存在，或者是邮箱未认证 使用自己发布的包使用 cnpm 安装依赖 1cnpm i km-vue-utils -S 在 main.js 文件 或者想要引入的文件导入 12import utils from \"km-vue-utils\";Vue.use(utils); 在想要引用的.vue 文件中直接写 123456789&lt;!-- 该名称由封装组件中的name属性决定 --&gt;&lt;tool-return-top&gt;&lt;/tool-return-top&gt;&lt;!-- 如果想引用组件中包含的方法，给Vue.prototype属性 Vue.prototype.$utils = utils; 在需要调用的地方直接写 this.$utils.方法文件.方法名; --&gt; 😜😜😜","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"node","slug":"vue/node","permalink":"http://superliebe.github.io/categories/vue/node/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"}]},{"title":"网站变灰技巧","slug":"网站变灰技巧","date":"2020-06-28T06:21:36.000Z","updated":"2020-07-15T03:15:50.291Z","comments":true,"path":"2020/06/28/网站变灰技巧/","link":"","permalink":"http://superliebe.github.io/2020/06/28/%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0%E6%8A%80%E5%B7%A7/","excerpt":"","text":"把网站变成灰色,来追悼逝去的英魂 12345678html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); filter: gray;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"}]},{"title":"docker常用命令操作、容器卷使用、dockefile等","slug":"docker常用命令操作","date":"2020-06-18T13:54:49.000Z","updated":"2020-07-19T11:32:55.672Z","comments":true,"path":"2020/06/18/docker常用命令操作/","link":"","permalink":"http://superliebe.github.io/2020/06/18/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","excerpt":"docker 常用命令小字典","text":"docker 常用命令小字典 镜像命令1docker version 系统信息，镜像和容器数量1docker info 查看所有本地主机上的镜像123456docker images# 可选项-a , --all #列出所有镜像-q , --quiet #只显示镜像的id 搜索镜像1docker search mysql 下载镜像12345678910111213docker pull mysql# 如果不写版本，默认使用latest最新版本# 指定版本下载docker pull mysql:5.7# 输出latest: Pulling from library/mysql8559a31e96f4: Pull complete # 分层下载。docker的核心联合文件系统Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6 #签名Status: Downloaded newer image for mysql:latest #真实地址 删除镜像如果容器正在运行中，是不能使用 rmi 这个命令的 123docker rmi 镜像名 # 删除镜像docker rmi -f 镜像id # 根据id删除镜像docker rmi -f $(docker -aq) # 删除全部镜像 容器命令说明：有了镜像才可以创建容器 新建容器并启动1234567891011121314151617181920docker pull centos # 下载centos镜像docker run [可选参数] image# 参数说明--m = \"name\" # 容器名字，用来区分容器-d # 后台运行-it # 使用交互方式运行，进入容器查看内容-P # 指定容器的端口 # -p 8080(主机端口):8080（容器端口）-p # 随机容器的端口# 测试，启动centos并进入$ docker run -it centos /bin/bash[root@f8ed75f63bcc /]# ls #查看容器内的centosbin dev etc home lib lib64 lost+found media mnt opt proc...#从容器中退回主机[root@f8ed75f63bcc /]# exit 查看运行中的容器1234docker ps # 查看运行中docker ps -a # 查看所有运行过+进行中的容器docker ps -n=2 # 显示最近正在运行的容器docker ps -aq # 显示所有运行过+进行中的容器的id 删除容器12docker rm 容器id #删除指定容器,不能删除正在运行的docker rm -f $(docker ps -aq) #删除所有容器，强制删除 退出容器12exit # 直接停止并退出Ctrl+P+Q #容器不停止退出 启动容器12docker start 容器id # 启动docker restart 容器id # 重启 停止容器12docker stop 容器id # 停止docker kill 容器id # 杀死 常用其他命令后台启动123docker run -d 镜像名# 常见问题：docker容器使用后台运行，就必须拥有前台进程，docker发现没有应用就会自动停止 持续打印日志1docker logs -tf --tail 10 容器名 查看 docker 容器内部的进程信息1docker top 容器id 查看容器元数据1docker inspect 容器id 进入当前正在运行的容器123456789# 我们容器通常是使用后台运行的，需要进入容器，修改一些配置# 命令# 进入容器后开启一个新的终端，可以在里面操作docker exec -it 容器id + 默认命令行（/bin/bash）# 进入容器正在执行的终端，不会启动新进程docker attach 容器id 从文件内容拷贝到主机1docker cp 容器id:容器内路径 目的的主机路径 可视化图形界面12docker run -d -p 8088:9000 \\--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 打包提交自己的镜像1234docker commit #提交容器为一个新的副本# 和 git 提交原理类似docker commit -m=\"提交信息\" -a=\"作者\" 容器id 目标镜像名:[tag] 容器卷容器之间可以有一个数据共享的技术，docker 容器的数据可以同步到本地，这就是卷技术 卷的设计目的就是数据的持久化，完全独立与容器的生命周期，因此 Docker 不会在容器删除时删除其挂载的数据卷。 特点： 数据卷可以在容器之间共享和重用数据。 卷的更改可以直接生效。 数据卷的更改不会包含在镜像的更新中。 数据卷的生命周期一直持续到没有容器使用它为止。 容器的持久化 容器间继承+共享数据 总结一句话：容器持久化和同步技术，容器间也是可以数据共享的！ 使用容器卷 方式-：直接使用命令来挂载 -v 12345# 指定路径挂载docker run -it -v 主机目录:容器目录#示例docker run -d -it -v /home/ceshi:/home centos /bin/bash 通过 docker inspect 容器id 查看容器详细信息 如果在容器内部对应的目录下增加文件，则对应的主机目录也会增加相关文件 具名挂载和匿名挂载 匿名挂载 不指定主机名，直接写容器内路径。 12345678-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx# 通过docker volume ls查看所有卷情况输出：DRIVER VOLUME NAMElocal 53d4bdcfd2df.... #匿名卷 具名挂载 12345678910-v 容器内路径docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx #指定了名字test-nginx# 通过docker volume ls查看所有卷情况输出：DRIVER VOLUME NAMElocal test-nginx #具名挂载# 通过 docker volume inspect test-nginx 查看具体卷情况 通过具名挂载可以方便的找到卷 Dockerfiledokcerfile 就是用来构建 docker 的镜像文件，也就是命令脚本，通过脚本生成镜像 方式二：命令脚本 创建 dockerfile1 文件并编辑 1234567#文件中的内容，指令必须大写，每个命令都是一层一层的FROM centos #基础镜像VOLUME [\"volume01\",\"volume02\"] #创建同步的目录，匿名挂载CMD /bin/bash # 运行/bin/bash 接下来开始构建 123456docker build -f dockerfile脚本地址 -t 镜像名:[tag] .# 例如：docker build -f dockerfile1 -t superkm/centos:1.0 .# -f dockerfile脚本地址# -t 生成镜像且生成到当前目录下，注意最后有个 . 然后查看docker images 就可以看到刚刚生成的镜像 进入自己创建的镜像docker run -it 容器id,然后 ls 查看目录就会看到，目录中包含 volume01,volume02 即为挂载的数据卷目录 docker inspect 容器id 查看容器详情 容器间同步挂载123456# 首先创建容器docker01docker run -it --name docker01 superkm/centos:1.0# 然后同步创建docker02docker run -it --name docker02 --volumes-from docker01 superkm/centos:1.0# 通过--volumes-from 实现容器间的数据同享，只要存在一个容器使用，其他容器删除文件也依旧存在 这样容器 docker01 就和 容器 docker02 挂载目录实时同步更新 登录 docker hub1docker login 输入 账号密码回车即可","categories":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"}]},{"title":"dockerToolbox的安装、配置镜像","slug":"dockerTool-box的安装配置","date":"2020-06-17T06:49:06.000Z","updated":"2020-07-02T14:13:08.796Z","comments":true,"path":"2020/06/17/dockerTool-box的安装配置/","link":"","permalink":"http://superliebe.github.io/2020/06/17/dockerTool-box%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。","text":"作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 docker 的基本介绍首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。 容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。 docker 与 传统虚拟机相比 特性 docker 容器 虚拟机 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 DockerToolbox 安装 dockerdocker 官网 win7、win8，非 win10 专业版等需要利用 docker toolbox 来安装，国内可以使用阿里云的镜像来下载，下载地址：http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/ 选择需要的服务，进行下一步安装 安装成功后，桌面会显示启动图标，双击运行 如果运行成功，进入 docker 如果失败，请看下方安装问题 docker toolbox 环境下 使用阿里云容器镜像加速器 在 Docker Quickstart Terminal 命令行输入命令： 1docker-machine ssh default 意思是采用 docker-machine 命令，以 ssh 方式，从当前 Docker Quickstart Terminal 窗口登录名称为 default 的 docker 虚拟机 此时窗口进入到了 docker 虚拟机，docker-machine 命令已经失效。linux 命令生效。 输入 cat /var/lib/boot2docker/profile 查看当前配置文件，其中第一句中 EXTRA_ARGS=&#39;--registry-mirror=http://******.io registry-mirror=后的网址即为当前镜像地址。 使用如下命令即可改为阿里云镜像地址 sudo sed -i &quot;s|EXTRA_ARGS=&#39;|EXTRA_ARGS=&#39;--registry-mirror=镜像地址 |g&quot; /var/lib/boot2docker/profile 添加后输入exit 退出 docker@default 重启 docker-machine docker-machine restart default 输入docker info查看镜像配置，registry 中可以看到配置的镜像 注意：需要登录阿里云容器镜像服务，获取自己的加速地址,点击进入阿里云镜像服务 安装问题问题一 双击 Docker Quickstart Terminal，提示 windows 正在查找 bash.exe。如果想亲自查找文件，请点击“浏览”。 问题原因一般出现这个问题，是因为之前已经安装过了 git，且 bash.exe 的路径与 Docker Toolbox 中不一致导致的。 解决办法右击 Docker Quickstart Terminal 的图标，修改前一段 bash 的路径为本机 git 安装路径。 问题二 配置了镜像加速后，重启电脑，通过 docker info 查看镜像又成了原来默认的地址 解决方法 如果你创建主机了就先删除默认的虚拟机 1docker-machine rm default 打开 docker 安装目录，编辑 start.sh 文件（如果你 docker 创建主机了你修改之后要删除主机 重新创建一台） 1\"$&#123;DOCKER_MACHINE&#125;\" create -d virtualbox $PROXY_ENV \"$&#123;VM&#125;\" 改成 1\"$&#123;DOCKER_MACHINE&#125;\" create --engine-registry-mirror=你的阿里云地址 -d virtualbox $PROXY_ENV \"$&#123;VM&#125;\" 运行Docker Quickstart Termin 通过 docker info 查看镜像地址 就再也不会改变啦，可以开开心心的push了~","categories":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"}]},{"title":"koa2下一代web开发框架","slug":"koa下一代web开发框架","date":"2020-06-10T06:30:51.000Z","updated":"2020-06-11T09:58:16.913Z","comments":true,"path":"2020/06/10/koa下一代web开发框架/","link":"","permalink":"http://superliebe.github.io/2020/06/10/koa%E4%B8%8B%E4%B8%80%E4%BB%A3web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/","excerpt":"next generation web framework for node.js","text":"next generation web framework for node.js koa官网 先看一下 koa 的交互流程概念 koa的工作原理koa中的中间件本质上就是一个async函数 123async (ctx, next) =&gt; &#123; await next();&#125; Koa 中间件的实现原理，也就是洋葱模型的实现原理，核心在于next的实现。next需要依次调用下一个middleware，当到最后一个的时候结束，这样后面middleware的promise先resolve，然后直到第一个，这样的流程也就是洋葱模型的流程了。 基本写法示例 12345678const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;);app.listen(3000); 打开浏览器 localhost:3000就可以看到Hello World koa-router路由配置1cnpm i -D koa-router 引入路由组件 1234567891011121314import Router from 'koa-router'// 或者// const Router = require('koa-router');// 定义routerconst router = new Router();//创建一个get方法router.get('/api',ctx=&gt;&#123; ctx.body = 'hello api!'&#125;)//router.prefix添加接口前缀router.prefix('/api') 路由组建压缩1cnpm i -S koa-combine-routers 添加安全头部 koa-helmet1cnpm i -S koa-helmet 添加静态文件 koa-static1cnpm i -S koa-static koa-body协议解析123456cnpm i koa-body// 使用方法，直接use即可const koaBody = require('koa-body');app.use(koaBody()); @koa/cors跨域处理123456cnpm i @koa/cors// 使用方法，直接use即可const cors = require('@koa/cors'); app.use(cors()); 配置koa的热加载 nodemon1cnpm i - D nodemon 使用npx nodemon src/index.js 监听文件内容变化，实现热更新","categories":[{"name":"koa","slug":"koa","permalink":"http://superliebe.github.io/categories/koa/"}],"tags":[{"name":"nodejs,koa","slug":"nodejs-koa","permalink":"http://superliebe.github.io/tags/nodejs-koa/"}]},{"title":"vue性能优化之路","slug":"vue-cli4性能优化之路","date":"2020-06-04T07:34:35.000Z","updated":"2020-07-31T03:23:10.763Z","comments":true,"path":"2020/06/04/vue-cli4性能优化之路/","link":"","permalink":"http://superliebe.github.io/2020/06/04/vue-cli4%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AF/","excerpt":"vue 生产环境上的性能优化：开启 Gzip、去掉打包后的 console、图片懒加载等","text":"vue 生产环境上的性能优化：开启 Gzip、去掉打包后的 console、图片懒加载等 开启 Gzip 压缩模式gizp 压缩是一种 http 请求优化方式，通过减少文件体积来提高加载速度，对于用户量多的网站，开启 gizp 压缩会大大降低服务器压力，提高加载速度，降低服务器流量成本 安装 compression-webpack-plugin 插件 1cnpm install compression-webpack-plugin --save-dev vue.config.js 配置 Gzip 压缩 1234567891011121314151617181920// 导入compression-webpack-pluginconst CompressionWebpackPlugin = require(\"compression-webpack-plugin\");// 定义压缩文件类型const productionGzipExtensions = [\"js\", \"css\"];module.exports = &#123; //统一配置打包插件 configureWebpack: &#123; plugins: [ new CompressionWebpackPlugin(&#123; filename: \"[path].gz[query]\", algorithm: \"gzip\", test: new RegExp(\"\\\\.(\" + productionGzipExtensions.join(\"|\") + \")$\"), //匹配文件名 threshold: 10240, //对10K以上的数据进行压缩 minRatio: 0.8, deleteOriginalAssets: false, //是否删除源文件 &#125;), ], &#125;,&#125;; npm run build 之后，对比之前的文件，平均压缩了 4 倍左右 接下来在服务器的 nginx 上配置 Gzip 123456gzip on; #开启或关闭gzip on offgzip_min_length 5k; #gzip压缩最小文件大小，超出进行压缩（自行调节）gzip_buffers 4 16k; #buffer 不用修改gzip_comp_level 4; #压缩级别:1-10，数字越大压缩的越好，时间也越长gzip_types text/plain application/x-javascript application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; # 压缩文件类型gzip_vary on; # 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩 修改后记得执行 nginx -s reload 一般浏览器都已支持.gz 的资源文件，在 http 请求的 Request Headers 中能看到 Accept-Encoding:gzip，加载速度会提升很大。 去掉打包后的 console 使用 babel-plugin-transform-remove-console 插件 安装依赖库 1cnpm install babel-plugin-transform-remove-console --save-dev 【babel.config.js】配置如下 123456789const plugins = [\"@vue/babel-plugin-transform-vue-jsx\"];// 生产环境移除consoleif (process.env.NODE_ENV === \"production\") &#123; plugins.push(\"transform-remove-console\");&#125;module.exports = &#123; plugins: plugins, presets: [\"@vue/cli-plugin-babel/preset\"],&#125;; 打包部署后，生产环境的 console 就全部去掉了~ 图片懒加载 使用 vue-lazyload 安装依赖 1cnpm i vue-lazyload -S main.js 中直接引用 123456789101112131415import VueLazyload from \"vue-lazyload\";Vue.use(VueLazyload);// or with optionsVue.use(VueLazyload, &#123; //预加载高度 preLoad: 1.3, //错误时显示的图片 error: \"static/about111.jpg\", //图片加载中显示的图片 loading: \"static/img/loading.gif\", //尝试加载次数 attempt: 1,&#125;); 在组件中使用时，将 img 标签的 src 换成 v-lazy： 未使用懒加载前的代码： 1&lt;li&gt;&lt;img class=\"g-img1\" src=\"static/1.jpg\" alt=\"\" /&gt;&lt;/li&gt; 使用懒加载后的代码： 1&lt;li&gt;&lt;img class=\"g-img1\" v-lazy=\"'static/1.jpg'\" alt=\"\" /&gt;&lt;/li&gt;","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://superliebe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://superliebe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"前端常用小方法合集","slug":"vue常用小方法合集","date":"2020-06-03T03:21:09.000Z","updated":"2020-07-23T08:50:13.195Z","comments":true,"path":"2020/06/03/vue常用小方法合集/","link":"","permalink":"http://superliebe.github.io/2020/06/03/vue%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/","excerpt":"记录一下 项目中经常使用的小方法","text":"记录一下 项目中经常使用的小方法 vue相关一：获取 url 地址栏参数例如：/placeList?id=1; 1this.$route.query.id(id为连接上的参数名称); 二：向下一个页面传递对象 (query 传参)父.vue 12345678this.$router.push(&#123; path: \"/placeAdd\", query: item,&#125;);//path和query均为固定key名//path：跳转路径//query: 传递参数对象//item:数组对象 子.vue 1this.$route.query.item; 三：父组件向子组件传值父.vue 123456/*引入子组件*/&lt;child-v ref=\"chil\"&gt;&lt;/child-v&gt;;/*script *showHover为子元素内的方法*/this.$refs.chil.showMessage(\"父组件调用子组件方法啦\"); 子.vue 123456//只需要正常定义方法接参即可methods: &#123; showMessage(text) &#123; console.log(text) &#125;&#125; 四：父子组件相互调用vue2.x vue 子组件调用父组件方法： 子组件：this.$emit(‘xx’); 父组件:定义 yy 方法，并在引用子组件时传参,如@xx=”yy” vue 父组件调用子组件方法： 子组件：定义 xx 方法 父组件：引用子组件时加上 ref=”yy”,调用方法为 this.$refs.yy.xx() vue3.x vue 子组件调用父组件方法： 父组件:定义 yy 方法，并在引用子组件时传参,如@xx=”yy” 12345678//子组件setup(props, &#123; emit &#125;) &#123; const clickEvent = () =&gt; &#123; console.log(\"clickEvent\"); //调用父组件的方法，并传值 emit(\"sendMesg\", state.result); &#125;;&#125; 五：阻止父元素冒泡事件123&lt;div @click=\"a\"&gt; &lt;button @click=\"b\"&gt;&lt;/button&gt;&lt;/div&gt; 当触发 button 的事件 a 时，b 事件也会被触发 解决办法：在 button 上添加@click.stop=”b”，来阻止事件冒泡。 123&lt;div @click=\"a\"&gt; &lt;button @click.stop=\"b\"&gt;&lt;/button&gt;&lt;/div&gt; 六：vue 修改 data 数据后页面未渲染 强制渲染 1this.$forceUpdate(); 使用 Vue.set 12345Vue.set(target, key, value);// target：要更改的数据源(可以是对象或者数组)// key：要更改的具体数据// value ：重新赋的值 js相关一：数组操作去掉指定数组对象 id 相同的元素1arr.splice(arr.findIndex(item &#x3D;&gt; item.id &#x3D;&#x3D; id), 1) 过滤对象数组中key值相同的数据1234567891011121314151617181920212223242526272829const arr =[ &#123; \"count\": 1095, \"month\": \"三月\", &#125;, &#123; \"count\": 1106, \"month\": \"三月\", &#125;, &#123; \"count\": 987, \"month\": \"四月\", &#125;, &#123; \"count\": 1166, \"month\": \"四月\", &#125;, &#123; \"count\": 753, \"month\": \"五月\", &#125;, &#123; \"count\": 891, \"month\": \"五月\", &#125;];const res = new Map();const new2 = arr.filter(item =&gt; !res.has(item.month) &amp;&amp; res.set(item.month, 1));console.log(arr.length, new2); 数组去重1234let arr = [1, 2, 2, 3, 3, 4, 4, 5, 6];let newArr = [...new Set(arr)];//结果：newArr = [1, 2, 3, 4, 5, 6] 随机取数组对象123456789101112131415161718192021222324function getArrayItems(arr, num) &#123; //新建一个数组,将传入的数组复制过来,用于运算,而不要直接操作传入的数组; var temp_array = new Array(); for (var index in arr) &#123; temp_array.push(arr[index]); &#125; //取出的数值项,保存在此数组 var return_array = new Array(); for (var i = 0; i &lt; num; i++) &#123; //判断如果数组还有可以取出的元素,以防下标越界 if (temp_array.length &gt; 0) &#123; //在数组中产生一个随机索引 var arrIndex = Math.floor(Math.random() * temp_array.length); //将此随机索引的对应的数组元素值复制出来 return_array[i] = temp_array[arrIndex]; //然后删掉此索引的数组元素,这时候temp_array变为新的数组 temp_array.splice(arrIndex, 1); &#125; else &#123; //数组中数据项取完后,退出循环,比如数组本来只有10项,但要求取出20项. break; &#125; &#125; return return_array;&#125; 排序/操作123456789101112131415161718192021222324let a=[1,2,13,4,5]//倒序a.reverse();//[5, 4, 13, 2, 1]//默认按照转换为的字符串的诸个字符的Unicode位点进行排序a.sort();//[1,13，2,4,5]/* 针对数字排序* 如果 小于 0 ，那么 a 会被排列到 b 之前；* 如果 等于 0 ， a 和 b 的相对位置不变。* 如果 大于 0 ， b 会被排列到 a 之前。*/arr.sort((a, b) =&gt; a - b);a.unshift();//5,代表数组长度；a.unshift(0);//返回6，数组长度；此时a=[0, 1, 2, 3, 4, 5]；//取出数组第一位a.shift();//1,不仅将数据取出，而且改变了数组，此时a=[2, 3, 4, 5]//取出数组最后一位a.pop();//5,一样也是改变了数组，此时a=[1, 2, 3, 4] 二：限制能输入数字类型+小数点 纯整数 1onkeyup = \"value=value.replace(/[^d]/g,'')\"; 数字类型+小数点 1&lt;input type=\"text\" oninput=\"value=value.replace(/[^\\d.]/g,'')\" /&gt; 限制输入两位小数 12345678&lt;input @input=\"handleInput2\" onkeyup=\"value=value.replace(/[^\\d.]/g,'')\" /&gt; //&lt;!--通过正则过滤小数点后两位, handleInput2(e) &#123; this.valuet =(e.match(/^\\d*(\\.?\\d&#123;0,2&#125;)/g)[0]) || null &#125;--&gt; 三：时间戳转化为时间1234567891011121314151617//将时间戳转化为日期function timestampToTime(timestamp) &#123; var date = new Date(timestamp); //时间戳为10位需*1000，时间戳为13位的话不需乘1000 var Y = date.getFullYear() + \"-\"; var M = (date.getMonth() + 1 &lt; 10 ? \"0\" + (date.getMonth() + 1) : date.getMonth() + 1) + \"-\"; var D = (date.getDate() &lt; 10 ? \"0\" + date.getDate() : date.getDate()) + \" \"; var h = (date.getHours() &lt; 10 ? \"0\" + date.getHours() : date.getHours()) + \":\"; var m = (date.getMinutes() &lt; 10 ? \"0\" + date.getMinutes() : date.getMinutes()) + \":\"; var s = date.getSeconds() &lt; 10 ? \"0\" + date.getSeconds() : date.getSeconds(); return Y + M + D + h + m + s;&#125; 四：计算两个时间相差日期123456789101112131415161718192021222324252627//startData,endData均为时间戳function timesDiffer(startData, endData) &#123; var date1 = startData; //开始时间 var date2 = endData; //结束时间 var date3 = parseInt(date2) - parseInt(date1); //时间差的毫秒数 //计算出相差天数 var days = Math.floor(date3 / (24 * 3600 * 1000)); //计算出小时数 var leave1 = date3 % (24 * 3600 * 1000); //计算天数后剩余的毫秒数 var hours = Math.floor(leave1 / (3600 * 1000)); //计算相差分钟数 var leave2 = leave1 % (3600 * 1000); //计算小时数后剩余的毫秒数 var minutes = Math.floor(leave2 / (60 * 1000)); //计算相差秒数 var leave3 = leave2 % (60 * 1000); //计算分钟数后剩余的毫秒数 var seconds = Math.round(leave3 / 1000); if (hours &lt;= 0 &amp;&amp; minutes &lt;= 0 &amp;&amp; seconds &lt;= 0) &#123; //时间小于0s的操作 &#125; else &#123; hours = hours &lt; 10 ? \"0\" + hours : hours; minutes = minutes &lt; 10 ? \"0\" + minutes : minutes; seconds = seconds &lt; 10 ? \"0\" + seconds : seconds; return hours + \":\" + minutes + \":\" + seconds; &#125;&#125; 五：下载文件流1234567891011//下载文件流function operateFile(file, filename) &#123; // var filename = ''; let url = window.URL.createObjectURL(file.data); let link = document.createElement(\"a\"); link.style.display = \"none\"; link.href = url; link.setAttribute(\"download\", filename + \".xls\"); document.body.appendChild(link); link.click();&#125; 六：计算 n 天前后的日期123456789101112131415function getBeforeDate(strDate, n) &#123; //strDate 为字符串日期 如:'2020-01-01' n为你要传入的参数，当前为0，前一天为-1，后一天为1 let datt = strDate.split(\"-\"); //这边给定一个特定时间 var newDate = new Date(datt[0], datt[1] - 1, datt[2]); let befminuts = newDate.getTime() + 1000 * 60 * 60 * 24 * parseInt(n); //计算前几天用减，计算后几天用加，最后一个就是多少天的数量 let beforeDat = new Date(); beforeDat.setTime(befminuts); let befMonth = beforeDat.getMonth() + 1; let mon = befMonth &gt;= 10 ? befMonth : \"0\" + befMonth; let befDate = beforeDat.getDate(); let da = befDate &gt;= 10 ? befDate : \"0\" + befDate; var newDate = beforeDat.getFullYear() + \"-\" + mon + \"-\" + da; console.log(newDate); return newDate;&#125; 七：ASCII 码排序参数123456789function objKeySort(obj) &#123; //obj排序对象 var newkey = Object.keys(obj).sort(); var newObj = &#123;&#125;; //创建一个新的对象，用于存放排好序的键值对 for (var i = 0; i &lt; newkey.length; i++) &#123; newObj[newkey[i]] = obj[newkey[i]]; &#125; return newObj; //返回排好序的新对象&#125; 八：如何平滑滚动到页面顶部12345678910const scrollToTop = () =&gt; &#123; const c = document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); &#125; &#125; // 事例 scrollToTop(); //返回排好序的新对象 九：如何获得两个日期之间的差异（以天为单位）12345const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; (dateFinal - dateInitial) / (1000 * 3600 * 24); // 事例 getDaysDiffBetweenDates(new Date('2020-12-13'), new Date('2020-12-22')); // 9 十：解析动态json数据 1234567891011121314151617// 取出key和value的值。再封装到一个数组里面。 let userData = 动态json数据;let userArray=[];for (let [key, value] of Object.entries(userData)) &#123; userArray.push(&#123;\"时间\":key,\"人数\":value&#125;); console.log(userArray)&#125;//只取key值：for (let key of Object.keys(obj)) &#123; &#125;//只取value值 for (let value of Object.values(obj)) &#123; &#125; 十一：点击复制文本12345678910let httpUrl = this.herfAddress; //此处为需要被复制的文本let oInput = document.createElement(\"input\");oInput.value = httpUrl;document.body.appendChild(oInput);oInput.select(); // 选择对象document.execCommand(\"Copy\"); // 执行浏览器复制命令oInput.className = \"oInput\";oInput.style.display = \"none\";console.log(\"链接复制成功\"); 十二：禁止微信用户修改字体大小微信 webview 内置了调整字体大小的功能，用户可以根据实际情况进行调整。 安卓： 123456789101112131415161718192021&lt;script&gt; (function() &#123; if (typeof WeixinJSBridge == \"object\" &amp;&amp; typeof WeixinJSBridge.invoke == \"function\") &#123; handleFontSize(); &#125; else &#123; if (document.addEventListener) &#123; document.addEventListener(\"WeixinJSBridgeReady\", handleFontSize, false); &#125; else if (document.attachEvent) &#123; document.attachEvent(\"WeixinJSBridgeReady\", handleFontSize); document.attachEvent(\"onWeixinJSBridgeReady\", handleFontSize); &#125; &#125; function handleFontSize() &#123; // 设置网页字体为默认大小 WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize' : 0 &#125;); // 重写设置网页字体大小的事件 WeixinJSBridge.on('menu:setfont', function() &#123; WeixinJSBridge.invoke('setFontSizeCallback', &#123; 'fontSize' : 0 &#125;); &#125;); &#125; &#125;)();&lt;/script&gt; ios 123456body &#123; /* IOS禁止微信调整字体大小 */ -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; -moz-text-size-adjust: 100% !important;&#125; 十三：px 与 rem 换算rem 是根据 iPhone6 换算的，根据设计出的 px 尺寸除以 100 带上 rem 单位即可，平常 14px 换算成 rem 是 0.28rem 1234567891011121314151617//rem换算(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = \"orientationchange\" in window ? \"orientationchange\" : \"resize\", recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; if (clientWidth &gt;= 750) &#123; docEl.style.fontSize = \"100px\"; &#125; else &#123; docEl.style.fontSize = 100 * (clientWidth / 750) + \"px\"; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(\"DOMContentLoaded\", recalc, false);&#125;)(document, window); 十四、取整1、只保留整数部分1parseInt(5.1234); // 5 2、向下取整 （效果等同于parseInt）1Math.floor(5.1234); // 5 3、向上取整 （有小数，整数部分+1）1Math.ceil(5.1234); // 6 4、四舍五入12Math.round(5.1234); // 5Math.round(5.6789); // 6 5、绝对值1Math.abs(-1); // 1 6、返回两数中的较大者1Math.max(1,2); // 2 7、返回两数中的较小者1Math.min(1,2); // 1 8、随机数1Math.random(); 十五、拷贝1、浅拷贝1234let a=[1,2,3]let b=a;b.push(4);//这时输出a的值为[1,2,3,4]; b的值也是[1,2,3,4] 2、深拷贝 方法一 1234let a=[1,2,3]let b=a.concat();b.push(4);//此时 a的值为[1, 2, 3]，b的值为[1,2,3,4] 方法二 1234let a=[1,2,3]let b=Object.assign(&#123;&#125;, a);b.push(4);//此时 a的值为[1, 2, 3]，b的值为[1,2,3,4] css相关一：超出部分省略1234567891011/*行数限制，超出部分省略*/display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;overflow: hidden;/*宽度限制，超出部分省略*/max-width: 4.6rem;overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 二：文本两端对齐1text-align: justify; 三：中文间隔1letter-spacing: 4px; 四：英文自动换行1word-wrap: break-word 五：禁止图片长按保存1pointer-events:none; 六：背景渐变色1background: -webkit-linear-gradient(left top,#F98530, #FAB03D); 七：input placeholder样式1234input::-webkit-input-placeholder &#123; opacity:0.3; color:#fff ; &#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"}]},{"title":"yarn使安装健步如飞","slug":"yarn使安装健步如飞","date":"2020-06-01T13:55:20.000Z","updated":"2020-07-21T10:01:09.826Z","comments":true,"path":"2020/06/01/yarn使安装健步如飞/","link":"","permalink":"http://superliebe.github.io/2020/06/01/yarn%E4%BD%BF%E5%AE%89%E8%A3%85%E5%81%A5%E6%AD%A5%E5%A6%82%E9%A3%9E/","excerpt":"yarn 快速、可靠、安全的依赖管理工具。","text":"yarn 快速、可靠、安全的依赖管理工具。 看栗子说话采用 cnpm 和 yarn 安装 webpack 工具 cnpm 效果图（总花费 60s） yarn 效果图（总花费 11s） 🙄 为什么要用 yarn速度超快 Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。 超级安全 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 超级可靠 使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。 🧐 更新淘宝源12345678# yarn+淘宝源，飞一般的速度yarn config get registry# https://registry.yarnpkg.comyarn config set registry https://registry.npm.taobao.orgyarn config get registry# https://registry.npm.taobao.org 从 npm 迁移1234567891011npm install === yarnnpm install [package] --save === yarn add [package]npm install [package] --save-dev === yarn add [package] --devnpm install [package] --global === yarn global add [package]npm uninstall [package] --save === yarn remove [package]rm -rf node_modules &amp;&amp; npm install === yarn upgrade yarn 官网","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"node","slug":"vue/node","permalink":"http://superliebe.github.io/categories/vue/node/"}],"tags":[{"name":"npm,yarn","slug":"npm-yarn","permalink":"http://superliebe.github.io/tags/npm-yarn/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2020-05-31T06:22:32.000Z","updated":"2020-07-21T10:03:25.768Z","comments":true,"path":"2020/05/31/linux常用命令/","link":"","permalink":"http://superliebe.github.io/2020/05/31/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Linux，全称 GNU/Linux，是一套免费使用和自由传播的类 UNIX 操作系统","text":"Linux，全称 GNU/Linux，是一套免费使用和自由传播的类 UNIX 操作系统 文件相关 cd dirname 目录路径跳转 mkdir dirname 创建目录 touch filename 创建文件 vi filename 编辑文件 cat filename 查看文件 echo ‘123456’ &gt;&gt; test.txt 在 test.txt 文件尾部增加一行 ‘123123’ echo ‘123456’ &gt; test.txt 覆盖 test.txt 文件的内容为 ‘hello world’ rm text.txt 删除 text.txt 文件 rm -r textdir 删除 testdir 目录 rm -rf 强制删除 wget 文件地址 下载文件 tar zxvf 文件 （如 apache-tomcat-9.0.17.tar.zg：解压缩文件 tar 后面的参数 z 代表 gz 等结尾的压缩文件，x 代表解压缩，v 显示所有的解压过程，f 代表归档的名字） tar zcvf 文件名（如 apache-tomcat-9.0.18.tar.gz） 文件目录：讲文件目录 压缩为 文件名为 apache-tomcat-9.0.18.tar.gz ps -ef | grep 进程名： 查看进程（筛选进程） kill -9 进程 pid: 杀死 进程 查看系统服务 service 服务名 status: 如 （service sshd status :查询 ssh 服务的运行状态） service 服务名 stop :关闭某个服务 service 服务名 restart:重启某个服务 systemctl status firewalld.service: 查看某个服务运行状态 使用 root 用户连接 linux 服务器1ssh root@ip 防火墙设置检查防火墙 firewall-cmd --permanent --query-port=10022/tcp 如果是 no,就添加一下 firewall-cmd --permanent --add-port=10022/tcp 成功后再重载防火墙 firewall-cmd --reload 再重启下防火墙服务 systemctl restart firewalld.service","categories":[{"name":"linux","slug":"linux","permalink":"http://superliebe.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://superliebe.github.io/tags/linux/"}]},{"title":"常用Markdown语法","slug":"常用Markdown语法","date":"2020-05-24T04:32:35.000Z","updated":"2020-07-21T10:03:58.485Z","comments":true,"path":"2020/05/24/常用Markdown语法/","link":"","permalink":"http://superliebe.github.io/2020/05/24/%E5%B8%B8%E7%94%A8Markdown%E8%AF%AD%E6%B3%95/","excerpt":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档 💡 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 一、标题 使用 # 表示标题，一级标题使用一个 # ，二级标题使用两个 ## ，以此类推，共有六级标题。# 和标题之间记得有个空格哦。 一级标题二级标题三级标题四级标题五级标题六级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 二、引用使用 &gt; 表示引用， &gt;&gt; 表示引用里面再套一层引用，依次类推。 ❗ 部分编辑器不支持多级嵌套，建议不要使用 示例 这是一级引用 这是二级引用 这是三级引用 这是一级引用 1234567&gt; 这是一级引用&gt;&gt; &gt; 这是二级引用&gt; &gt;&gt; &gt; &gt; 这是三级引用&gt; 这是一级引用 三、代码块使用 3 个连续的` 符号包围起来表示代码块。可以指定语言来使代码高亮。 示例 12345$(document).ready(function() &#123; $(&#39;pre code&#39;).each(function(i, block) &#123; hljs.highlightBlock(block); &#125;);&#125;); 12345$(document).ready(function () &#123; $(\"pre code\").each(function (i, block) &#123; hljs.highlightBlock(block); &#125;);&#125;); 行内代码 使用``表示行内代码。本页部分文字中间的英文字母就是使用行内代码标记标记的。 示例 这是 javascript 代码 1这是&#96;javascript&#96;代码 四、链接使用 [](link) 表示行内链接。其中： [] 内的内容为要添加链接的文字。 link 为链接地址。 示例 这是跳转百度的链接 1这是跳转[百度](https:&#x2F;&#x2F;www.baidu.com)的链接 五、导入图片使用 ![Alt text](/path/to/img.jpg) 导入图片。其中： Alt text 为如果图片无法显示时显示的文字； /path/to/img.jpg 为图片所在路径； 本地引用是图片直接存储到本地通过相对路径引用，无需网络连接 上传图片将把图片上传至图床，这样在文档或图片移动时认可访问图片 示例 1![Markdown](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;03&#x2F;14&#x2F;I8wCZN4r9UltqTd.jpg) 六、Todo List小写 x 表示已完成， 空格表示未完成 支持数学公式 支持 TodoList 支持自定义样式 支持自定义图床 1234- [x] 支持数学公式- [x] 支持TodoList- [x] 支持自定义样式- [ ] 支持自定义图床 七、粗体，斜体，高亮和删除线 使用 ** 表示粗体。 1**粗体** 使用 * 或者 _ 表示 _斜体_。 1*斜体* 使用 *** 表示 全部粗体和斜体 1***全部粗体和斜体*** 使用 == 表示 ==高亮== ❗ 部分编辑器不支持高亮 1&#x3D;&#x3D;高亮&#x3D;&#x3D; 使用~~表示 删除 1~~删除~~ 八、列表使用 1. 1. 1. 表示有序列表，使用 * 或 - 或 + 表示无序列表。 无序列表或有序列表标记和后面的文字之间要有一个空格隔开。 有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例 1 所示。 无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的，如例 2 所示。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。 _示例 1_：有序列表 第 1 行 第 2 行 第 3 行 1231. 第1行1. 第2行1. 第3行 _示例 2_：无序列表 一级无序列表内容 二级无序列表内容 三级无序列表内容 一级无序列表内容 1234+ 一级无序列表内容 - 二级无序列表内容 - 三级无序列表内容* 一级无序列表内容 九、分割线使用 --- 或者 *** 或者 * * * 表示水平分割线。 只要 * 或者 - 大于等于三个就可组成一条平行线。 使用 --- 作为水平分割线时，要在它的前后都空一行，防止 --- 被当成标题标记的表示方式。 示例 12345---**** * * 十、表格默认表格Heading | Heading | Heading——- | ——- | ——-Cell | Cell | CellCell | Cell | Cell 1234Heading | Heading | Heading------- | ------- | -------Cell | Cell | CellCell | Cell | Cell 对齐方式：Heading | Heading | Heading:—– | :—-: | ——:Left | Center | RightLeft | Center | Right 1234Heading | Heading | Heading:----- | :----: | ------:Left | Center | RightLeft | Center | Right 十一、emoji使用 :emoji代码: 在 markdown 里添加 emoji 👻 点击这里查看所有支持的 emoji 代码 ❗ 部分编辑器不支持 emoji code 建议直接输入 emoji，点击这里查看并复制 emoji","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://superliebe.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://superliebe.github.io/tags/Markdown/"}]},{"title":"kbone+vue创建支持web和微信小程序的项目","slug":"kbone-vue创建支持web和微信小程序的项目","date":"2020-04-26T07:28:52.000Z","updated":"2020-07-01T07:58:50.343Z","comments":true,"path":"2020/04/26/kbone-vue创建支持web和微信小程序的项目/","link":"","permalink":"http://superliebe.github.io/2020/04/26/kbone-vue%E5%88%9B%E5%BB%BA%E6%94%AF%E6%8C%81web%E5%92%8C%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%B9%E7%9B%AE/","excerpt":"Kbone 是腾讯开发的解决微信小程序和 Web 端同构的框架。简单来说就是只写一套代码，编译结果可以在 web 端和小程序上运行。","text":"Kbone 是腾讯开发的解决微信小程序和 Web 端同构的框架。简单来说就是只写一套代码，编译结果可以在 web 端和小程序上运行。 Kbone 特点 支持多种前端框架，如：vue、react、preact 等，并且能够保持该框架的完整； 页面渲染的内容需要用 js 中的 document 方法来渲染，提供常用的 DOM/BOM 接口； 小程序端开发仍可使用小程序本身特性； 更专注于微信和小程序的开发； Webpack 与 Kbone 是强耦合的，开发需借助 Webpack 提供的基本依赖 一：安装 kbone-cli命令行安装kbone-cli脚手架，用于创建kbone项目 1cnpm install -g kbone-cli 二：创建对应的 kbone 项目1kbone init my-app 可以根据自己所用到的技术选择对应的选项（本项目采用kbone+vue），回车确定。 创建成功之后，基本目录情况和 vue-cli4 目录差不多，其中在 build 文件夹里 miniprogram.config.js 进行小程序的配置，比如 appid 之类 三：在 main.js 中引入 kbone-ui，使项目 ui 更贴近微信风格（可选）安装 kbone-ui 1npm i kbone-ui main.js 中引入样式文件 1234import KboneUI from \"kbone-ui\";import \"kbone-ui/lib/weui/weui.css\";Vue.use(KboneUI); 四：运行项目12345678&#x2F;&#x2F; 开发小程序端npm run mp&#x2F;&#x2F; 开发 Web 端npm run web&#x2F;&#x2F; 构建 Web 端npm run build web端运行效果图 小程序端运行效果图npm run mp 之后 会在dis文件中创建对应的小程序文件，使用微信开发者工具打开预览， 注意：官方提醒，尽量使用kbone-ui开发，目前功能正在逐步完善兼容，使用其他组件库可能会出现问题 kbone 官方文档","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"微信小程序","slug":"vue/微信小程序","permalink":"http://superliebe.github.io/categories/vue/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"kbone,vue","slug":"kbone-vue","permalink":"http://superliebe.github.io/tags/kbone-vue/"}]}],"categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://superliebe.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"数据结构","slug":"数据结构","permalink":"http://superliebe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"typescript","slug":"typescript","permalink":"http://superliebe.github.io/categories/typescript/"},{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"vite","slug":"vue/vite","permalink":"http://superliebe.github.io/categories/vue/vite/"},{"name":"pwa","slug":"pwa","permalink":"http://superliebe.github.io/categories/pwa/"},{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"},{"name":"git","slug":"git","permalink":"http://superliebe.github.io/categories/git/"},{"name":"node","slug":"vue/node","permalink":"http://superliebe.github.io/categories/vue/node/"},{"name":"koa","slug":"koa","permalink":"http://superliebe.github.io/categories/koa/"},{"name":"linux","slug":"linux","permalink":"http://superliebe.github.io/categories/linux/"},{"name":"Markdown","slug":"Markdown","permalink":"http://superliebe.github.io/categories/Markdown/"},{"name":"微信小程序","slug":"vue/微信小程序","permalink":"http://superliebe.github.io/categories/vue/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://superliebe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"算法","slug":"算法","permalink":"http://superliebe.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"typescript","slug":"typescript","permalink":"http://superliebe.github.io/tags/typescript/"},{"name":"vite","slug":"vite","permalink":"http://superliebe.github.io/tags/vite/"},{"name":"pwa","slug":"pwa","permalink":"http://superliebe.github.io/tags/pwa/"},{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"},{"name":"git","slug":"git","permalink":"http://superliebe.github.io/tags/git/"},{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"},{"name":"nodejs,koa","slug":"nodejs-koa","permalink":"http://superliebe.github.io/tags/nodejs-koa/"},{"name":"npm,yarn","slug":"npm-yarn","permalink":"http://superliebe.github.io/tags/npm-yarn/"},{"name":"linux","slug":"linux","permalink":"http://superliebe.github.io/tags/linux/"},{"name":"Markdown","slug":"Markdown","permalink":"http://superliebe.github.io/tags/Markdown/"},{"name":"kbone,vue","slug":"kbone-vue","permalink":"http://superliebe.github.io/tags/kbone-vue/"}]}