{"meta":{"title":"superKM的博客","subtitle":"superKM","description":"superKM的个人博客","author":"superKM","url":"http://superliebe.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-24T08:46:04.913Z","updated":"2020-05-24T08:46:04.913Z","comments":true,"path":"404.html","permalink":"http://superliebe.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-07-09T14:41:53.010Z","updated":"2020-07-09T14:41:53.010Z","comments":false,"path":"about/index.html","permalink":"http://superliebe.github.io/about/index.html","excerpt":"","text":".card { --card-bg-color: hsl(240, 31%, 25%); --card-bg-color-transparent: hsla(240, 31%, 25%, 0.7); position: relative; width: 300px; } .card .card-borders { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; } .card .card-borders .border-top { position: absolute; top: 0; width: 100%; height: 2px; background: var(--card-bg-color); transform: translateX(-100%); animation: slide-in-horizontal 0.8s cubic-bezier(0.645, 0.045, 0.355, 1) forwards; } .card .card-borders .border-right { position: absolute; right: 0; width: 2px; height: 100%; background: var(--card-bg-color); transform: translateY(100%); animation: slide-in-vertical 0.8s cubic-bezier(0.645, 0.045, 0.355, 1) forwards; } .card .card-borders .border-bottom { position: absolute; bottom: 0; width: 100%; height: 2px; background: var(--card-bg-color); transform: translateX(100%); animation: slide-in-horizontal-reverse 0.8s cubic-bezier(0.645, 0.045, 0.355, 1) forwards; } .card .card-borders .border-left { position: absolute; top: 0; width: 2px; height: 100%; background: var(--card-bg-color); transform: translateY(-100%); animation: slide-in-vertical-reverse 0.8s cubic-bezier(0.645, 0.045, 0.355, 1) forwards; } .card .card-content { display: flex; flex-direction: column; align-items: center; padding: 40px 0 40px 0; font-family: Lato, sans-serif; background: var(--card-bg-color-transparent); box-shadow: 0 0px 0.6px rgba(0, 0, 0, 0.028), 0 0px 1.3px rgba(0, 0, 0, 0.04), 0 0px 2.5px rgba(0, 0, 0, 0.05), 0 0px 4.5px rgba(0, 0, 0, 0.06), 0 0px 8.4px rgba(0, 0, 0, 0.072), 0 0px 20px rgba(0, 0, 0, 0.1); opacity: 0; transform: scale(0.6); animation: bump-in 0.5s 0.8s forwards; } .card .card-content .avatar { width: 120px; height: 120px; border-radius: 50%; margin-bottom: 40px; opacity: 0; transform: scale(0.6); animation: bump-in 0.5s 1s forwards; } .card .card-content .username { position: relative; font-size: 26px; letter-spacing: 2px; margin-bottom: 40px; color: transparent; animation: fill-text-white 1.2s 2s forwards; } .card .card-content .username::before { position: absolute; content: \"\"; top: 0; left: 0; width: 100%; height: 100%; color: black; background: #35b9f1; transform: scaleX(0); transform-origin: left; animation: slide-in-out 1.2s 1.2s cubic-bezier(0.75, 0, 0, 1) forwards; } .card .card-content .social-icons { display: flex; position:relative; } .card .card-content .social-icons .social-icon { position: relative; display: flex; justify-content: center; align-items: center; width: 2.5em; height: 2.5em; margin: 0 15px; border-radius: 50%; color: white; text-decoration: none; } .card .card-content .social-icons .social-icon:nth-child(1)::before { animation-delay: 2.1s; } .card .card-content .social-icons .social-icon:nth-child(1)::after { animation-delay: 2.2s; } .card .card-content .social-icons .social-icon:nth-child(1) svg { animation-delay: 2.3s; } .card .card-content .social-icons .social-icon:nth-child(2)::before { animation-delay: 2.2s; } .card .card-content .social-icons .social-icon:nth-child(2)::after { animation-delay: 2.3s; } .card .card-content .social-icons .social-icon:nth-child(2) svg { animation-delay: 2.4s; } .card .card-content .social-icons .social-icon:nth-child(3)::before { animation-delay: 2.3s; } .card .card-content .social-icons .social-icon:nth-child(3)::after { animation-delay: 2.4s; } .card .card-content .social-icons .social-icon:nth-child(3) svg { animation-delay: 2.5s; } .card .card-content .social-icons .social-icon::before, .card .card-content .social-icons .social-icon::after { position: absolute; content: \"\"; top: 0; left: 0; width: 100%; height: 100%; border-radius: inherit; transform: scale(0); } .card .card-content .social-icons .social-icon::before { background: #f7f1e3; animation: scale-in 0.5s cubic-bezier(0.75, 0, 0, 1) forwards; } .card .card-content .social-icons .social-icon::after { background: #2C3E50; animation: scale-in 0.5s cubic-bezier(0.75, 0, 0, 1) forwards; } .card .card-content .social-icons .social-icon svg { z-index: 1; transform: scale(0); animation: scale-in 0.5s cubic-bezier(0.75, 0, 0, 1) forwards; } .card .card-content .card_wx:hover>.qrcode{ opacity:1; bottom: -83px; } .card .card-content .card_wx .qrcode{ width: 124px; border: 6px solid #FFF; border-radius: 9px; position: absolute!important; right: -136px; bottom: -43px; opacity:0; max-width: 1000%; box-shadow: 2px 2px 10px 2px #e8e8e8; } @keyframes bump-in { 50% { transform: scale(1.05); } to { opacity: 1; transform: scale(1); } } @keyframes slide-in-horizontal { 50% { transform: translateX(0); } to { transform: translateX(100%); } } @keyframes slide-in-horizontal-reverse { 50% { transform: translateX(0); } to { transform: translateX(-100%); } } @keyframes slide-in-vertical { 50% { transform: translateY(0); } to { transform: translateY(-100%); } } @keyframes slide-in-vertical-reverse { 50% { transform: translateY(0); } to { transform: translateY(100%); } } @keyframes slide-in-out { 50% { transform: scaleX(1); transform-origin: left; } 50.1% { transform-origin: right; } 100% { transform: scaleX(0); transform-origin: right; } } @keyframes fill-text-white { to { color: white; } } @keyframes scale-in { to { transform: scale(1); } } 一个前端菜菜 😶 个人情况 郑州大学本科毕业 热爱开源，热爱技术，热爱探索、热爱生活、热爱身边的一切。 😝 擅长领域 vue全家桶，桶装干净又卫生 微信小程序开发 ，微信网页开发，移动webApp开发 jquery 框架 ， ES6语法 ，Git Docker 部署项目 Nginx 代理 nodejs ，webpack kbone + vue 同时支持web和小程序 tradingview K 线图制作 常用开发工具 微信开发者工具、vscode、mysqlWorkbench、ps6、蓝湖、IDEA、webstorm 、Fiddle、Postman、磨刀。 🧐 探索学习中 vite vue3打包技术 koa2 基于nodejs 下一代web开发框架 noSql 非关系型的数据库 Flutter 跨平台多端webApp开发 pwa 渐进式web应用 🙃 CSDN 博客 – superKM😇 期望 前端全栈攻城狮占领全地球，奥里给！"},{"title":"所有分类","date":"2020-05-24T08:23:24.038Z","updated":"2020-05-24T08:23:24.038Z","comments":true,"path":"categories/index.html","permalink":"http://superliebe.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-24T08:45:19.617Z","updated":"2020-05-24T08:45:19.617Z","comments":true,"path":"mylist/index.html","permalink":"http://superliebe.github.io/mylist/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-05-24T13:52:18.053Z","updated":"2020-05-24T13:52:18.053Z","comments":true,"path":"friends/index.html","permalink":"http://superliebe.github.io/friends/index.html","excerpt":"推荐一个技术博主","text":"推荐一个技术博主"},{"title":"所有标签","date":"2020-05-24T08:44:21.697Z","updated":"2020-05-24T08:44:21.697Z","comments":true,"path":"tags/index.html","permalink":"http://superliebe.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"dockefile的使用","slug":"dockerfile的使用","date":"2020-07-09T13:54:49.000Z","updated":"2020-07-09T15:57:07.887Z","comments":true,"path":"2020/07/09/dockerfile的使用/","link":"","permalink":"http://superliebe.github.io/2020/07/09/dockerfile%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"docker 是用来构建 docker 镜像文件，命令参数的脚本。 构建步骤 编写一个 dockerfile 文件。 docker build 构建成为一个镜像。 docker run 运行镜像。 docker push 发布镜像（dockerhub , 阿里云仓库）。 很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！ dockerfile 的构建过程基础知识 每个指令都必须是大写字母。 执行从上到下顺序执行。 #表示注释 每个指令都会创建一个新的镜像层并提交。 docker 镜像逐渐成为企业交付的标准，所以你懂的。 DockerFile: 构建文件，定义了一切的步骤，源代码 DockerImages : 通过 DockerFile 构建生成的镜像，最终发布和运行的产品！ Docker 容器 : 容器就是镜像运行起来提供服务 dockerfile 指令123456789101112FROM #基础镜像，一切从这里开始构建MAINTAINER (maintainer) #镜像是谁写的，姓名+邮箱RUN #镜像构建的时候需要运行的命令ADD #添加内容，如添加一个tomcat的压缩包WORKDIR #镜像的工作目录VOLUME #挂载的目录EXPOST #暴露端口配置CMD #指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代！ENTRYPOINT (entrypoint) #指定这个容器启动的时候要运行的命令，可以追加命令！ONBUILD #当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的指令，触发指令！COPY # 类似ADD ，将文件拷贝到镜像中！ENV # 构建的时候设置环境变量！ 实战测试Docker Hub 中 99% 的镜像都是从 FROM scratch 这个基础镜像过来的！然后配置需要的软件和配置来进行构建 创建一个自己的centos 在 home 目录中创建 dockerfile 文件夹，vim mydockerfile ,编写dockerfile文件 123456789101112131415161718192021# 编写dockersfile文件#基于centos基础环境FROM centosMAINTAINER superkm&lt;583902049@qq.com&gt;# 设置环境变量ENV MYPATH /user/local #默认进入的目录WORKDIR $MYPATH# 执行安装的一些命令RUN yum -y install vimRUN yum -y install net-tools#暴漏的端口EXPOSE 80#输出信息，默认进入命令行CMD echo $MYPATHCMD echo \"---end---\"CMD /bin/bash 构建镜像 1234567docker build -f mydockerfile -t mycentos:0.1 .# -f dockerfile脚本文件# -t 生成目标镜像且生成到当前目录下，注意最后有个 .# 构建成功的提示# Successfully built 3c490273278b# Successfully tagged mycentos:0.1 测试运行，正常使用 我们拿到一个镜像，可以研究它是怎么做的 列出镜像的变更历史 docker history 镜像id","categories":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"}]},{"title":"git常用命令","slug":"git常用命令","date":"2020-07-01T07:54:34.000Z","updated":"2020-07-01T08:06:47.279Z","comments":true,"path":"2020/07/01/git常用命令/","link":"","permalink":"http://superliebe.github.io/2020/07/01/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"","categories":[{"name":"git","slug":"git","permalink":"http://superliebe.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://superliebe.github.io/tags/git/"}]},{"title":"npm发布vue组件包（可扩展）","slug":"npm发布第一个包","date":"2020-06-29T03:23:42.000Z","updated":"2020-07-03T03:17:34.559Z","comments":true,"path":"2020/06/29/npm发布第一个包/","link":"","permalink":"http://superliebe.github.io/2020/06/29/npm%E5%8F%91%E5%B8%83%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%85/","excerpt":"😶 NPM 是随同 NodeJS 一起安装的 javascript 包管理工具，能解决 NodeJS 代码部署上的很多问题","text":"😶 NPM 是随同 NodeJS 一起安装的 javascript 包管理工具，能解决 NodeJS 代码部署上的很多问题 发布前的准备注册一个 npm 账号 前往 NPM 官网进行注册 初始化项目这里用的是webpack-simple,可以理解为精简版的vue-cli。 如果没有全局安装 vue 的话，需要先安装 1cnpm i -g @vue/cli-init 然后再初始化 vue 项目，我们要写的是一个简单的 vue 组件，不需要依赖那么多而庞大的配置，所以，这里我们用简介版本的 webapck 配置模板 1vue init webpack-simple 项目名（最好去npm官网搜一下，防止重复） 创建之后的基本目录 创建 vue 插件并发布创建组件文件夹举个例子：封装一个返回顶部的小组件 既然是封装组件，那我们在 src 下面创建一个 plugins 文件放我们的插件，但是考虑到万一要写很多个的情况，当前组件的相关文件下创建一个 returnTop 文件夹，下面创建 returnTop.vue 和 index.js 先，结构变成下面这样： 切换到当前根目录，安装依赖，启动项目 123cnpm installcnpm run dev 编写组件代码示例代码returnTop.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;template&gt; &lt;div class=\"right-return-top\"&gt; &lt;div class=\"return-top\" @click=\"returnTop\" v-show=\"topShow\"&gt; &lt;img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAAHdbkFIAAAACXBIWXMAAAsSAAALEgHS3X78AAADGUlEQVR4nO2aT2vTYBzHv0/S9aKw7rJz34E5mP6zrRmOjeFgKozBcFAZwkAc6sHrttNgUBBPA5HNi5eBsJPX1k1XT9p3UF/B+g4iadI2ydI0T9P0SfX3hZDmeZI8n9/3efL8acJ0XYefJN/cICckHEfLGR3zCWB+BqjWWSfNYHBsT/O6/diZuaSamW/KvZPCRzEBH5wnPMnp2Ck5y3SE+TiruH2ZAOTQIkKXMM03WM4onYoz5K48m/4BE6kdxOEGCc/UBVXHLQmd7bYM6/cBDmv77lMjrsaNvI7t4u/RbrCaNdDmANzBbnnwTW6MDsam3W3rDzOp3vHLku55XpBec5ioJY6hIYVV6AgIYOoBvLvDQTK6ySQDZhgc+6TkTvPsOr005U/BRl7BVsG3ux6m0RxYzSpIsl+uKmji+EKJFmBBtRc8hy+Ndi/PmMCZbaCJaj04yKBxZuC2pKa4r/HZqCsmAOEA1AgJgAAIgACmaFasqftIsL3+NMxrdmz9PrL+mw0gGoymvBFuFtqo3EuJAVjPG1PyWQDXeF4cGWI0gLVct/A/Vso1XpRGguAHWMl2C2/i8480gGc9iNdlbgg+gMVMv/CzK3P1c/r91AHx9j4XRHAATVV6hZ83nEuvD5d2iHc8AHxLqQdq2jf/VenGCxhamhEAARAAAQyT8J5QtITXgGiRATFgECoyIAYMQkUGxIBBqMiAGDAIFd9L+6DS1DQY0pAZIBs2W3vZtpdcx55pjmtbOKy1xo0ajQFABcDemO95ACDQlxA8orVADBiESqwBm4U0tgqh/t4OKzGPwHpegYQaZDZrdXBNyEzDx8t2gKvHqskasJZTIFuBe48CphHHFxMzYjIGrGT7gfeHQTNYGY8gsxPXMGjmvf8WuRHRGrCYMQOXbIF3gzu7cga3XaxAwolrHtCExDRU65EZEY0BxqsUZqtxyRb4ecM/mJ1SBbLNiO61Rxxfw3EouhZgfOYnsxpktDq1+PUnXy3ulk0jJPYJ1XolGkiaCNFEiAyIAYNQkQExYBAqMiAGDEJFBsSAQaj+bwMA/AVQMPelPAquSAAAAABJRU5ErkJggg==\" /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"ToolReturnTop\", //决定引用组件的名称 data() &#123; return &#123; scroll: 0, topShow: false, &#125;; &#125;, mounted() &#123; window.addEventListener(\"scroll\", this.scrolls); &#125;, methods: &#123; returnTop() &#123; window.scroll(0, 0); &#125;, scrolls() &#123; this.scroll = document.documentElement &amp;&amp; document.documentElement.scrollTop + document.body.scrollTop; if (this.scroll &gt; window.innerHeight / 2) &#123; this.topShow = true; &#125; else &#123; this.topShow = false; &#125; &#125;, &#125;, &#125;;&lt;/script&gt;&lt;style scoped&gt; /* 返回顶部 */ .right-return-top &#123; position: fixed; left: 0; right: 0; bottom: 20px; z-index: 9; margin: auto; &#125; /* .return-top &#123; width: 0.63rem; height: 0.63rem; z-index: 9; margin: 0 auto; background-color: #f9f9f9; box-shadow: 0 0.01rem 0.05rem 0 rgba(0, 0, 0, 0.2) !important; -webkit-box-shadow: 0 0.01rem 0.05rem 0 rgba(0, 0, 0, 0.2) !important; border-radius: 1rem; &#125; */ .return-top &#123; width: 40px; height: 40px; z-index: 9; margin: 0 auto; background-color: #f9f9f9; box-shadow: 0 0.01rem 0.05rem 0 rgba(0, 0, 0, 0.2) !important; -webkit-box-shadow: 0 0.01rem 0.05rem 0 rgba(0, 0, 0, 0.2) !important; border-radius: 1rem; -webkit-animation: show 350ms ease-out forwards 1; animation: show 350ms ease-out forwards 1; &#125; .return-top img &#123; width: 100%; height: 100%; &#125; @-webkit-keyframes show &#123; 0% &#123; -webkit-transform: rotate(0deg); &#125; 25% &#123; opacity: 0.5; -webkit-transform: rotate(-3deg) translateY(-0.2rem); &#125; 75% &#123; -webkit-transform: rotate(3deg); &#125; 100% &#123; opacity: 0.9; -webkit-transform: rotate(0deg); &#125; &#125; @keyframes show &#123; 0% &#123; transform: rotate(0deg); &#125; 25% &#123; opacity: 0.5; transform: rotate(-3deg) translateY(-0.2rem); &#125; 75% &#123; transform: rotate(3deg); &#125; 100% &#123; opacity: 0.9; transform: rotate(0deg); &#125; &#125;&lt;/style&gt; 编辑 returTop／index.js 文件，目的：将该组件作为 Vue 插件 123456789101112131415161718// sumFunction 插件对应组件的名字import returnTop from \"./returnTop\";// Vue.js 的插件应当有一个公开方法 install 。第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象// 此处注意，组件需要添加name属性，代表注册的组件名称，也可以修改成其他的returnTop.install = (Vue) =&gt; Vue.component(returnTop.name, returnTop); //注册组件// 标签的方式引入//const install = function(Vue, opts = &#123;&#125;) &#123;// Vue.component(sumFunction.name, sumFunction);//&#125;/* 支持使用标签的方式引入 Vue是全局变量时，自动install *///if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123;// install(window.Vue);//&#125;export default returnTop; 此处需要注意的是 install。 Vue 的插件必须提供一个公开方法 install，该方法会在你使用该插件，也就是 Vue.use(yourPlugin)时被调用。这样也就给 Vue 全局注入了你的所有的组件。 在src目录下创建index.js文件,用来统一管理组件 1234567891011121314151617181920212223import Vue from 'vue';import ReturnTop from './plugins/returnTop/index.js';//返回顶部// ...如果还有的话继续添加const components = [ ReturnTop,]//循环遍历注册组件，就可以向其他ui组件库那样，使用Vue.use()来全局使用const install = function (Vue, opts = &#123;&#125;) &#123; components.map(component =&gt; &#123; Vue.component(component.name, component); &#125;)&#125;/* 支持使用标签的方式引入 */if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue);&#125;export default &#123; install, ReturnTop, //在这里多写一次可以单独调用，例如：Vue.use(vueutils.ReturnTop)&#125; 修改 package.json12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"name\": \"km-vue-utils\", \"description\": \"vue常用工具合集\", \"version\": \"0.0.1\", \"author\": \"SuperKM\", \"license\": \"MIT\", // 开源协议 // 采用commonJs入口文件，如果不配置，我们在其他项目中就不用import XX from XX来引用了，只能以包名作为起点来指定相对的路径 \"main\": \"dist/index.js\", \"jsnext:main\": \"src/index.js\", // 采用es6模块化入口 \"private\": false, // 因为组件包是公用的，所以private为false \"scripts\": &#123; \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --open --hot\", \"build\": \"cross-env NODE_ENV=production webpack --progress --hide-modules\" &#125;,// 指定代码所在的仓库地址 \"repository\": &#123; \"type\": \"git\", \"url\": \"https://github.com/superliebe/vueTools.git\" &#125;,// 提交bug的地址 \"bugs\": &#123; \"url\": \"https://github.com/superliebe/vueTools/issues\" &#125;, // 项目官网的url \"homepage\": \"https://github.com/superliebe/vueTools\", \"keywords\": [ \"vue\", \"component\", \"tools\", \"superkm\" ], // 指定关键字 \"dependencies\": &#123; \"vue\": \"^2.5.11\" &#125;, \"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\" ], \"devDependencies\": &#123; ... &#125;&#125; 修改.gitignore因为要用 dist 文件夹，所以在.gitignore 文件中把 dist/去掉。 修改 webpack.config.js1234567891011121314151617181920212223// 原module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'build.js' &#125;...&#125;// 新const NODE_ENV = process.env.NODE_ENVmodule.exports = &#123; entry: NODE_ENV == 'development' ? './src/main.js' : './src/index.js', output: &#123; path: path.resolve(__dirname, './dist'), publicPath: '/dist/', filename: 'index.js', libraryTarget: 'umd', // 指定输出格式 umdNamedDefine: true // 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define &#125;...｝ ❗ 发布 npm 之前必须做两件事情。 ❤️ - 必须 npm run build 打包一下。 ❤️ - 必须 修改 package.json 中的版本号。 发布包到 npm 已经注册过 npm 账号，首先登陆，登陆过一次之后，就可以直接发布 1234567npm login --registry http://registry.npmjs.org//适用于使用了淘宝镜像加速的//或者npm login //未采用镜像加速过 输入账号-密码-邮箱后，提示 Logged in as *** on http://registry.npmjs.org/. 就是登陆成功了 然后直接发布 1npm publish --registry http://registry.npmjs.org 发布成功后提示，前往自己的 npm 库中就可以查看到刚刚发布的 npm 包 npm 库中 如果想删除发布的包 1npm unpublish km-vuetools --force --registry http://registry.npmjs.org npm 发布中常见错误 409 Conflict npm login 或者 npm adduser 时 输入完账号密码邮箱后 提示 E409 Conflict 报错 一般因为淘宝镜像的原因 解决方案,直接 registry 镜像源 1npm login --registry http://registry.npmjs.org npm ERR! 403 可能是包名已经存在，或者是邮箱未认证 使用自己发布的包使用 cnpm 安装依赖 1cnpm i km-vue-utils -S 在 main.js 文件 或者想要引入的文件导入 12import utils from \"km-vue-utils\";Vue.use(utils); 在想要引用的.vue 文件中直接写 123456789&lt;!-- 该名称由封装组件中的name属性决定 --&gt;&lt;tool-return-top&gt;&lt;/tool-return-top&gt;&lt;!-- 如果想引用组件中包含的方法，给Vue.prototype属性 Vue.prototype.$utils = utils; 在需要调用的地方直接写 this.$utils.方法文件.方法名; --&gt; 😜😜😜","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"node","slug":"vue/node","permalink":"http://superliebe.github.io/categories/vue/node/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"}]},{"title":"网站变灰技巧","slug":"网站变灰技巧","date":"2020-06-28T06:21:36.000Z","updated":"2020-06-28T06:24:18.882Z","comments":true,"path":"2020/06/28/网站变灰技巧/","link":"","permalink":"http://superliebe.github.io/2020/06/28/%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0%E6%8A%80%E5%B7%A7/","excerpt":"","text":"把网站变成灰色,来追悼逝去的英魂 12345678html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: grayscale(100%); filter: gray;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"}]},{"title":"docker常用命令操作、容器卷使用、dockefile等","slug":"docker常用命令操作","date":"2020-06-18T13:54:49.000Z","updated":"2020-07-09T02:24:14.335Z","comments":true,"path":"2020/06/18/docker常用命令操作/","link":"","permalink":"http://superliebe.github.io/2020/06/18/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","excerpt":"docker 常用命令小字典","text":"docker 常用命令小字典 镜像命令版本信息1docker version 系统信息，镜像和容器数量1docker info 查看所有本地主机上的镜像123456docker images# 可选项-a , --all #列出所有镜像-q , --quiet #只显示镜像的id 搜索镜像1docker search mysql 下载镜像12345678910111213docker pull mysql# 如果不写版本，默认使用latest最新版本# 指定版本下载docker pull mysql:5.7# 输出latest: Pulling from library/mysql8559a31e96f4: Pull complete # 分层下载。docker的核心联合文件系统Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6 #签名Status: Downloaded newer image for mysql:latest #真实地址 删除镜像如果容器正在运行中，是不能使用 rmi 这个命令的 123docker rmi 镜像名 # 删除镜像docker rmi -f 镜像id # 根据id删除镜像docker rmi -f $(docker -aq) # 删除全部镜像 容器命令说明：有了镜像才可以创建容器 新建容器并启动1234567891011121314151617181920docker pull centos # 下载centos镜像docker run [可选参数] image# 参数说明--m = \"name\" # 容器名字，用来区分容器-d # 后台运行-it # 使用交互方式运行，进入容器查看内容-P # 指定容器的端口 # -p 8080(主机端口):8080（容器端口）-p # 随机容器的端口# 测试，启动centos并进入$ docker run -it centos /bin/bash[root@f8ed75f63bcc /]# ls #查看容器内的centosbin dev etc home lib lib64 lost+found media mnt opt proc...#从容器中退回主机[root@f8ed75f63bcc /]# exit 查看运行中的容器1234docker ps # 查看运行中docker ps -a # 查看所有运行过+进行中的容器docker ps -n=2 # 显示最近正在运行的容器docker ps -aq # 显示所有运行过+进行中的容器的id 删除容器12docker rm 容器id #删除指定容器,不能删除正在运行的docker rm -f $(docker ps -aq) #删除所有容器，强制删除 退出容器12exit # 直接停止并退出Ctrl+P+Q #容器不停止退出 启动容器12docker start 容器id # 启动docker restart 容器id # 重启 停止容器12docker stop 容器id # 停止docker kill 容器id # 杀死 常用其他命令后台启动123docker run -d 镜像名# 常见问题：docker容器使用后台运行，就必须拥有前台进程，docker发现没有应用就会自动停止 持续打印日志1docker logs -tf --tail 10 容器名 查看 docker 容器内部的进程信息1docker top 容器id 查看容器元数据1docker inspect 容器id 进入当前正在运行的容器123456789# 我们容器通常是使用后台运行的，需要进入容器，修改一些配置# 命令# 进入容器后开启一个新的终端，可以在里面操作docker exec -it 容器id + 默认命令行（/bin/bash）# 进入容器正在执行的终端，不会启动新进程docker attach 容器id 从文件内容拷贝到主机1docker cp 容器id:容器内路径 目的的主机路径 可视化图形界面12docker run -d -p 8088:9000 \\--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 打包提交自己的镜像1234docker commit #提交容器为一个新的副本# 和 git 提交原理类似docker commit -m=\"提交信息\" -a=\"作者\" 容器id 目标镜像名:[tag] 容器卷容器之间可以有一个数据共享的技术，docker 容器的数据可以同步到本地，这就是卷技术 卷的设计目的就是数据的持久化，完全独立与容器的生命周期，因此 Docker 不会在容器删除时删除其挂载的数据卷。 特点： 数据卷可以在容器之间共享和重用数据。 卷的更改可以直接生效。 数据卷的更改不会包含在镜像的更新中。 数据卷的生命周期一直持续到没有容器使用它为止。 容器的持久化 容器间继承+共享数据 总结一句话：容器持久化和同步技术，容器间也是可以数据共享的！ 使用容器卷 方式-：直接使用命令来挂载 -v 12345# 指定路径挂载docker run -it -v 主机目录:容器目录#示例docker run -d -it -v /home/ceshi:/home centos /bin/bash 通过 docker inspect 容器id 查看容器详细信息 如果在容器内部对应的目录下增加文件，则对应的主机目录也会增加相关文件 具名挂载和匿名挂载 匿名挂载 不指定主机名，直接写容器内路径。 12345678-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx# 通过docker volume ls查看所有卷情况输出：DRIVER VOLUME NAMElocal 53d4bdcfd2df.... #匿名卷 具名挂载 12345678910-v 容器内路径docker run -d -P --name nginx02 -v test-nginx:/etc/nginx nginx #指定了名字test-nginx# 通过docker volume ls查看所有卷情况输出：DRIVER VOLUME NAMElocal test-nginx #具名挂载# 通过 docker volume inspect test-nginx 查看具体卷情况 通过具名挂载可以方便的找到卷 Dockerfiledokcerfile 就是用来构建 docker 的镜像文件，也就是命令脚本，通过脚本生成镜像 方式二：命令脚本 创建 dockerfile1 文件并编辑 1234567#文件中的内容，指令必须大写，每个命令都是一层一层的FROM centos #基础镜像VOLUME [\"volume01\",\"volume02\"] #创建同步的目录，匿名挂载CMD /bin/bash # 运行/bin/bash 接下来开始构建 123456docker build -f dockerfile脚本地址 -t 镜像名:[tag] .# 例如：docker build -f dockerfile1 -t superkm/centos:1.0 .# -f dockerfile脚本地址# -t 生成镜像且生成到当前目录下，注意最后有个 . 然后查看docker images 就可以看到刚刚生成的镜像 进入自己创建的镜像docker run -it 容器id,然后 ls 查看目录就会看到，目录中包含 volume01,volume02 即为挂载的数据卷目录 docker inspect 容器id 查看容器详情 容器间同步挂载123456# 首先创建容器docker01docker run -it --name docker01 superkm/centos:1.0# 然后同步创建docker02docker run -it --name docker02 --volumes-from docker01 superkm/centos:1.0# 通过--volumes-from 实现容器间的数据同享，只要存在一个容器使用，其他容器删除文件也依旧存在 这样容器 docker01 就和 容器 docker02 挂载目录实时同步更新 登录 docker hub1docker login 输入 账号密码回车即可","categories":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"}]},{"title":"dockerToolbox的安装、配置镜像","slug":"dockerTool-box的安装配置","date":"2020-06-17T06:49:06.000Z","updated":"2020-07-02T14:13:08.796Z","comments":true,"path":"2020/06/17/dockerTool-box的安装配置/","link":"","permalink":"http://superliebe.github.io/2020/06/17/dockerTool-box%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。","text":"作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 docker 的基本介绍首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。 容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。 docker 与 传统虚拟机相比 特性 docker 容器 虚拟机 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 DockerToolbox 安装 dockerdocker 官网 win7、win8，非 win10 专业版等需要利用 docker toolbox 来安装，国内可以使用阿里云的镜像来下载，下载地址：http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/ 选择需要的服务，进行下一步安装 安装成功后，桌面会显示启动图标，双击运行 如果运行成功，进入 docker 如果失败，请看下方安装问题 docker toolbox 环境下 使用阿里云容器镜像加速器 在 Docker Quickstart Terminal 命令行输入命令： 1docker-machine ssh default 意思是采用 docker-machine 命令，以 ssh 方式，从当前 Docker Quickstart Terminal 窗口登录名称为 default 的 docker 虚拟机 此时窗口进入到了 docker 虚拟机，docker-machine 命令已经失效。linux 命令生效。 输入 cat /var/lib/boot2docker/profile 查看当前配置文件，其中第一句中 EXTRA_ARGS=&#39;--registry-mirror=http://******.io registry-mirror=后的网址即为当前镜像地址。 使用如下命令即可改为阿里云镜像地址 sudo sed -i &quot;s|EXTRA_ARGS=&#39;|EXTRA_ARGS=&#39;--registry-mirror=镜像地址 |g&quot; /var/lib/boot2docker/profile 添加后输入exit 退出 docker@default 重启 docker-machine docker-machine restart default 输入docker info查看镜像配置，registry 中可以看到配置的镜像 注意：需要登录阿里云容器镜像服务，获取自己的加速地址,点击进入阿里云镜像服务 安装问题问题一 双击 Docker Quickstart Terminal，提示 windows 正在查找 bash.exe。如果想亲自查找文件，请点击“浏览”。 问题原因一般出现这个问题，是因为之前已经安装过了 git，且 bash.exe 的路径与 Docker Toolbox 中不一致导致的。 解决办法右击 Docker Quickstart Terminal 的图标，修改前一段 bash 的路径为本机 git 安装路径。 问题二 配置了镜像加速后，重启电脑，通过 docker info 查看镜像又成了原来默认的地址 解决方法 如果你创建主机了就先删除默认的虚拟机 1docker-machine rm default 打开 docker 安装目录，编辑 start.sh 文件（如果你 docker 创建主机了你修改之后要删除主机 重新创建一台） 1\"$&#123;DOCKER_MACHINE&#125;\" create -d virtualbox $PROXY_ENV \"$&#123;VM&#125;\" 改成 1\"$&#123;DOCKER_MACHINE&#125;\" create --engine-registry-mirror=你的阿里云地址 -d virtualbox $PROXY_ENV \"$&#123;VM&#125;\" 运行Docker Quickstart Termin 通过 docker info 查看镜像地址 就再也不会改变啦，可以开开心心的push了~","categories":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"}]},{"title":"koa2下一代web开发框架","slug":"koa下一代web开发框架","date":"2020-06-10T06:30:51.000Z","updated":"2020-06-11T09:58:16.913Z","comments":true,"path":"2020/06/10/koa下一代web开发框架/","link":"","permalink":"http://superliebe.github.io/2020/06/10/koa%E4%B8%8B%E4%B8%80%E4%BB%A3web%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/","excerpt":"next generation web framework for node.js","text":"next generation web framework for node.js koa官网 先看一下 koa 的交互流程概念 koa的工作原理koa中的中间件本质上就是一个async函数 123async (ctx, next) =&gt; &#123; await next();&#125; Koa 中间件的实现原理，也就是洋葱模型的实现原理，核心在于next的实现。next需要依次调用下一个middleware，当到最后一个的时候结束，这样后面middleware的promise先resolve，然后直到第一个，这样的流程也就是洋葱模型的流程了。 基本写法示例 12345678const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;);app.listen(3000); 打开浏览器 localhost:3000就可以看到Hello World koa-router路由配置1cnpm i -D koa-router 引入路由组件 1234567891011121314import Router from 'koa-router'// 或者// const Router = require('koa-router');// 定义routerconst router = new Router();//创建一个get方法router.get('/api',ctx=&gt;&#123; ctx.body = 'hello api!'&#125;)//router.prefix添加接口前缀router.prefix('/api') 路由组建压缩1cnpm i -S koa-combine-routers 添加安全头部 koa-helmet1cnpm i -S koa-helmet 添加静态文件 koa-static1cnpm i -S koa-static koa-body协议解析123456cnpm i koa-body// 使用方法，直接use即可const koaBody = require('koa-body');app.use(koaBody()); @koa/cors跨域处理123456cnpm i @koa/cors// 使用方法，直接use即可const cors = require('@koa/cors'); app.use(cors()); 配置koa的热加载 nodemon1cnpm i - D nodemon 使用npx nodemon src/index.js 监听文件内容变化，实现热更新","categories":[{"name":"koa","slug":"koa","permalink":"http://superliebe.github.io/categories/koa/"}],"tags":[{"name":"nodejs,koa","slug":"nodejs-koa","permalink":"http://superliebe.github.io/tags/nodejs-koa/"}]},{"title":"vue-cli4性能优化之路","slug":"vue-cli4性能优化之路","date":"2020-06-04T07:34:35.000Z","updated":"2020-06-10T06:19:52.365Z","comments":true,"path":"2020/06/04/vue-cli4性能优化之路/","link":"","permalink":"http://superliebe.github.io/2020/06/04/vue-cli4%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AF/","excerpt":"vue 生产环境上的性能优化：开启 Gzip、去掉打包后的 console、图片懒加载等","text":"vue 生产环境上的性能优化：开启 Gzip、去掉打包后的 console、图片懒加载等 开启 Gzip 压缩模式gizp 压缩是一种 http 请求优化方式，通过减少文件体积来提高加载速度，对于用户量多的网站，开启 gizp 压缩会大大降低服务器压力，提高加载速度，降低服务器流量成本 安装 compression-webpack-plugin 插件 1cnpm install compression-webpack-plugin --save-dev vue.config.js 配置 Gzip 压缩 1234567891011121314151617181920// 导入compression-webpack-pluginconst CompressionWebpackPlugin = require(\"compression-webpack-plugin\");// 定义压缩文件类型const productionGzipExtensions = [\"js\", \"css\"];module.exports = &#123; //统一配置打包插件 configureWebpack: &#123; plugins: [ new CompressionWebpackPlugin(&#123; filename: \"[path].gz[query]\", algorithm: \"gzip\", test: new RegExp(\"\\\\.(\" + productionGzipExtensions.join(\"|\") + \")$\"), //匹配文件名 threshold: 10240, //对10K以上的数据进行压缩 minRatio: 0.8, deleteOriginalAssets: false, //是否删除源文件 &#125;), ], &#125;,&#125;; npm run build 之后，对比之前的文件，平均压缩了 4 倍左右 接下来在服务器的 nginx 上配置 Gzip 123456gzip on; #开启或关闭gzip on offgzip_min_length 5k; #gzip压缩最小文件大小，超出进行压缩（自行调节）gzip_buffers 4 16k; #buffer 不用修改gzip_comp_level 4; #压缩级别:1-10，数字越大压缩的越好，时间也越长gzip_types text/plain application/x-javascript application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; # 压缩文件类型gzip_vary on; # 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩 修改后记得执行 nginx -s reload 一般浏览器都已支持.gz 的资源文件，在 http 请求的 Request Headers 中能看到 Accept-Encoding:gzip，加载速度会提升很大。 去掉打包后的 console 使用 babel-plugin-transform-remove-console 插件 安装依赖库 1cnpm install babel-plugin-transform-remove-console --save-dev 【babel.config.js】配置如下 123456789const plugins = [\"@vue/babel-plugin-transform-vue-jsx\"];// 生产环境移除consoleif (process.env.NODE_ENV === \"production\") &#123; plugins.push(\"transform-remove-console\");&#125;module.exports = &#123; plugins: plugins, presets: [\"@vue/cli-plugin-babel/preset\"],&#125;; 打包部署后，生产环境的 console 就全部去掉了~ 图片懒加载 使用 vue-lazyload 安装依赖 1cnpm i vue-lazyload -S main.js 中直接引用 123456789101112131415import VueLazyload from \"vue-lazyload\";Vue.use(VueLazyload);// or with optionsVue.use(VueLazyload, &#123; //预加载高度 preLoad: 1.3, //错误时显示的图片 error: \"static/about111.jpg\", //图片加载中显示的图片 loading: \"static/img/loading.gif\", //尝试加载次数 attempt: 1,&#125;); 在组件中使用时，将 img 标签的 src 换成 v-lazy： 未使用懒加载前的代码： 1&lt;li&gt;&lt;img class=\"g-img1\" src=\"static/1.jpg\" alt=\"\" /&gt;&lt;/li&gt; 使用懒加载后的代码： 1&lt;li&gt;&lt;img class=\"g-img1\" v-lazy=\"'static/1.jpg'\" alt=\"\" /&gt;&lt;/li&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"}]},{"title":"vue常用小方法合集","slug":"vue常用小方法合集","date":"2020-06-03T03:21:09.000Z","updated":"2020-06-28T06:43:27.123Z","comments":true,"path":"2020/06/03/vue常用小方法合集/","link":"","permalink":"http://superliebe.github.io/2020/06/03/vue%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86/","excerpt":"记录一下 vue 项目中经常使用的小方法","text":"记录一下 vue 项目中经常使用的小方法 一：获取 url 地址栏参数例如：/placeList?id=1; 1this.$route.query.id(id为连接上的参数名称); 二：向下一个页面传递对象 (query 传参)父.vue 12345678this.$router.push(&#123; path: \"/placeAdd\", query: item,&#125;);//path和query均为固定key名//path：跳转路径//query: 传递参数对象//item:数组对象 子.vue 1this.$route.query.item; 三：父组件向子组件传值父.vue 123456/*引入子组件*/&lt;child-v ref=\"chil\"&gt;&lt;/child-v&gt;;/*script *showHover为子元素内的方法*/this.$refs.chil.showMessage(\"父组件调用子组件方法啦\"); 子.vue 123456//只需要正常定义方法接参即可methods: &#123; showMessage(text) &#123; console.log(text) &#125;&#125; 四：父子组件相互调用 vue 子组件调用父组件方法： 子组件：this.$emit(‘xx’); 父组件:定义 yy 方法，并在引用子组件时传参,如@xx=”yy” vue 父组件调用子组件方法： 子组件：定义 xx 方法 父组件：引用子组件时加上 ref=”yy”,调用方法为 this.$refs.yy.xx() 五：阻止父元素冒泡事件123&lt;div @click=\"a\"&gt; &lt;button @click=\"b\"&gt;&lt;/button&gt;&lt;/div&gt; 当触发 button 的事件 a 时，b 事件也会被触发 解决办法：在 button 上添加@click.stop=”b”，来阻止事件冒泡。 123&lt;div @click=\"a\"&gt; &lt;button @click.stop=\"b\"&gt;&lt;/button&gt;&lt;/div&gt; 六：数组操作去掉指定数组对象 id 相同的元素1arr.splice(arr.findIndex(item &#x3D;&gt; item.id &#x3D;&#x3D; id), 1) 过滤对象数组中key值相同的数据1234567891011121314151617181920212223242526272829const arr =[ &#123; \"count\": 1095, \"month\": \"三月\", &#125;, &#123; \"count\": 1106, \"month\": \"三月\", &#125;, &#123; \"count\": 987, \"month\": \"四月\", &#125;, &#123; \"count\": 1166, \"month\": \"四月\", &#125;, &#123; \"count\": 753, \"month\": \"五月\", &#125;, &#123; \"count\": 891, \"month\": \"五月\", &#125;];const res = new Map();const new2 = arr.filter(item =&gt; !res.has(item.month) &amp;&amp; res.set(item.month, 1));console.log(arr.length, new2); 数组去重1234let arr = [1, 2, 2, 3, 3, 4, 4, 5, 6];let newArr = [...new Set(arr)];//结果：newArr = [1, 2, 3, 4, 5, 6] 随机取数组对象123456789101112131415161718192021222324function getArrayItems(arr, num) &#123; //新建一个数组,将传入的数组复制过来,用于运算,而不要直接操作传入的数组; var temp_array = new Array(); for (var index in arr) &#123; temp_array.push(arr[index]); &#125; //取出的数值项,保存在此数组 var return_array = new Array(); for (var i = 0; i &lt; num; i++) &#123; //判断如果数组还有可以取出的元素,以防下标越界 if (temp_array.length &gt; 0) &#123; //在数组中产生一个随机索引 var arrIndex = Math.floor(Math.random() * temp_array.length); //将此随机索引的对应的数组元素值复制出来 return_array[i] = temp_array[arrIndex]; //然后删掉此索引的数组元素,这时候temp_array变为新的数组 temp_array.splice(arrIndex, 1); &#125; else &#123; //数组中数据项取完后,退出循环,比如数组本来只有10项,但要求取出20项. break; &#125; &#125; return return_array;&#125; 七：限制能输入数字类型+小数点 纯整数 1onkeyup = \"value=value.replace(/[^d]/g,'')\"; 数字类型+小数点 1&lt;input type=\"text\" oninput=\"value=value.replace(/[^\\d.]/g,'')\" /&gt; 八：vue 修改 data 数据后页面未渲染 强制渲染 1this.$forceUpdate(); 使用 Vue.set 12345Vue.set(target, key, value);// target：要更改的数据源(可以是对象或者数组)// key：要更改的具体数据// value ：重新赋的值 九：时间戳转化为时间1234567891011121314151617//将时间戳转化为日期function timestampToTime(timestamp) &#123; var date = new Date(timestamp); //时间戳为10位需*1000，时间戳为13位的话不需乘1000 var Y = date.getFullYear() + \"-\"; var M = (date.getMonth() + 1 &lt; 10 ? \"0\" + (date.getMonth() + 1) : date.getMonth() + 1) + \"-\"; var D = (date.getDate() &lt; 10 ? \"0\" + date.getDate() : date.getDate()) + \" \"; var h = (date.getHours() &lt; 10 ? \"0\" + date.getHours() : date.getHours()) + \":\"; var m = (date.getMinutes() &lt; 10 ? \"0\" + date.getMinutes() : date.getMinutes()) + \":\"; var s = date.getSeconds() &lt; 10 ? \"0\" + date.getSeconds() : date.getSeconds(); return Y + M + D + h + m + s;&#125; 十：计算两个时间相差日期123456789101112131415161718192021222324252627//startData,endData均为时间戳function timesDiffer(startData, endData) &#123; var date1 = startData; //开始时间 var date2 = endData; //结束时间 var date3 = parseInt(date2) - parseInt(date1); //时间差的毫秒数 //计算出相差天数 var days = Math.floor(date3 / (24 * 3600 * 1000)); //计算出小时数 var leave1 = date3 % (24 * 3600 * 1000); //计算天数后剩余的毫秒数 var hours = Math.floor(leave1 / (3600 * 1000)); //计算相差分钟数 var leave2 = leave1 % (3600 * 1000); //计算小时数后剩余的毫秒数 var minutes = Math.floor(leave2 / (60 * 1000)); //计算相差秒数 var leave3 = leave2 % (60 * 1000); //计算分钟数后剩余的毫秒数 var seconds = Math.round(leave3 / 1000); if (hours &lt;= 0 &amp;&amp; minutes &lt;= 0 &amp;&amp; seconds &lt;= 0) &#123; //时间小于0s的操作 &#125; else &#123; hours = hours &lt; 10 ? \"0\" + hours : hours; minutes = minutes &lt; 10 ? \"0\" + minutes : minutes; seconds = seconds &lt; 10 ? \"0\" + seconds : seconds; return hours + \":\" + minutes + \":\" + seconds; &#125;&#125; 十一：下载文件流1234567891011//下载文件流function operateFile(file, filename) &#123; // var filename = ''; let url = window.URL.createObjectURL(file.data); let link = document.createElement(\"a\"); link.style.display = \"none\"; link.href = url; link.setAttribute(\"download\", filename + \".xls\"); document.body.appendChild(link); link.click();&#125; 十二：计算 n 天前后的日期123456789101112131415function getBeforeDate(strDate, n) &#123; //strDate 为字符串日期 如:'2020-01-01' n为你要传入的参数，当前为0，前一天为-1，后一天为1 let datt = strDate.split(\"-\"); //这边给定一个特定时间 var newDate = new Date(datt[0], datt[1] - 1, datt[2]); let befminuts = newDate.getTime() + 1000 * 60 * 60 * 24 * parseInt(n); //计算前几天用减，计算后几天用加，最后一个就是多少天的数量 let beforeDat = new Date(); beforeDat.setTime(befminuts); let befMonth = beforeDat.getMonth() + 1; let mon = befMonth &gt;= 10 ? befMonth : \"0\" + befMonth; let befDate = beforeDat.getDate(); let da = befDate &gt;= 10 ? befDate : \"0\" + befDate; var newDate = beforeDat.getFullYear() + \"-\" + mon + \"-\" + da; console.log(newDate); return newDate;&#125; 十三：ASCII 码排序参数123456789function objKeySort(obj) &#123; //obj排序对象 var newkey = Object.keys(obj).sort(); var newObj = &#123;&#125;; //创建一个新的对象，用于存放排好序的键值对 for (var i = 0; i &lt; newkey.length; i++) &#123; newObj[newkey[i]] = obj[newkey[i]]; &#125; return newObj; //返回排好序的新对象&#125; 十四：如何平滑滚动到页面顶部12345678910const scrollToTop = () =&gt; &#123; const c = document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); &#125; &#125; // 事例 scrollToTop(); //返回排好序的新对象 十五：如何获得两个日期之间的差异（以天为单位）12345const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; (dateFinal - dateInitial) / (1000 * 3600 * 24); // 事例 getDaysDiffBetweenDates(new Date('2020-12-13'), new Date('2020-12-22')); // 9","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"}]},{"title":"yarn使安装健步如飞","slug":"yarn使安装健步如飞","date":"2020-06-01T13:55:20.000Z","updated":"2020-07-01T08:07:06.920Z","comments":true,"path":"2020/06/01/yarn使安装健步如飞/","link":"","permalink":"http://superliebe.github.io/2020/06/01/yarn%E4%BD%BF%E5%AE%89%E8%A3%85%E5%81%A5%E6%AD%A5%E5%A6%82%E9%A3%9E/","excerpt":"yarn 快速、可靠、安全的依赖管理工具。","text":"yarn 快速、可靠、安全的依赖管理工具。 看栗子说话采用 cnpm 和 yarn 安装 webpack 工具 cnpm 效果图（总花费 60s） yarn 效果图（总花费 11s） 🙄 为什么要用 yarn速度超快 Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。 超级安全 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。 超级可靠 使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。 🧐 更新淘宝源12345678# yarn+淘宝源，飞一般的速度yarn config get registry# https://registry.yarnpkg.comyarn config set registry https://registry.npm.taobao.orgyarn config get registry# https://registry.npm.taobao.org 从 npm 迁移1234567891011npm install === yarnnpm install [package] --save === yarn add [package]npm install [package] --save-dev === yarn add [package] --devnpm install [package] --global === yarn global add [package]npm uninstall [package] --save === yarn remove [package]rm -rf node_modules &amp;&amp; npm install === yarn upgrade yarn 官网","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"node","slug":"vue/node","permalink":"http://superliebe.github.io/categories/vue/node/"}],"tags":[{"name":"npm,yarn","slug":"npm-yarn","permalink":"http://superliebe.github.io/tags/npm-yarn/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2020-05-31T06:22:32.000Z","updated":"2020-07-01T07:58:47.544Z","comments":true,"path":"2020/05/31/linux常用命令/","link":"","permalink":"http://superliebe.github.io/2020/05/31/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Linux，全称 GNU/Linux，是一套免费使用和自由传播的类 UNIX 操作系统","text":"Linux，全称 GNU/Linux，是一套免费使用和自由传播的类 UNIX 操作系统 文件相关 cd dirname 目录路径跳转 mkdir dirname 创建目录 touch filename 创建文件 vi filename 编辑文件 cat filename 查看文件 echo ‘123456’ &gt;&gt; test.txt 在 test.txt 文件尾部增加一行 ‘123123’ echo ‘123456’ &gt; test.txt 覆盖 test.txt 文件的内容为 ‘hello world’ rm text.txt 删除 text.txt 文件 rm -r textdir 删除 testdir 目录 rm -rf 强制删除 wget 文件地址 下载文件 tar zxvf 文件 （如 apache-tomcat-9.0.17.tar.zg：解压缩文件 tar 后面的参数 z 代表 gz 等结尾的压缩文件，x 代表解压缩，v 显示所有的解压过程，f 代表归档的名字） tar zcvf 文件名（如 apache-tomcat-9.0.18.tar.gz） 文件目录：讲文件目录 压缩为 文件名为 apache-tomcat-9.0.18.tar.gz ps -ef | grep 进程名： 查看进程（筛选进程） kill -9 进程 pid: 杀死 进程 查看系统服务 service 服务名 status: 如 （service sshd status :查询 ssh 服务的运行状态） service 服务名 stop :关闭某个服务 service 服务名 restart:重启某个服务 systemctl status firewalld.service: 查看某个服务运行状态 使用 root 用户连接 linux 服务器1ssh root@ip 防火墙设置检查防火墙 firewall-cmd --permanent --query-port=10022/tcp 如果是 no,就添加一下 firewall-cmd --permanent --add-port=10022/tcp 成功后再重载防火墙 firewall-cmd --reload 再重启下防火墙服务 systemctl restart firewalld.service","categories":[{"name":"linux","slug":"linux","permalink":"http://superliebe.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://superliebe.github.io/tags/linux/"}]},{"title":"常用Markdown语法","slug":"常用Markdown语法","date":"2020-05-24T04:32:35.000Z","updated":"2020-07-02T09:28:18.345Z","comments":true,"path":"2020/05/24/常用Markdown语法/","link":"","permalink":"http://superliebe.github.io/2020/05/24/%E5%B8%B8%E7%94%A8Markdown%E8%AF%AD%E6%B3%95/","excerpt":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档 💡 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 一、标题 使用 # 表示标题，一级标题使用一个 # ，二级标题使用两个 ## ，以此类推，共有六级标题。# 和标题之间记得有个空格哦。 一级标题二级标题三级标题四级标题五级标题六级标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 二、引用使用 &gt; 表示引用， &gt;&gt; 表示引用里面再套一层引用，依次类推。 ❗ 部分编辑器不支持多级嵌套，建议不要使用 示例 这是一级引用 这是二级引用 这是三级引用 这是一级引用 1234567&gt; 这是一级引用&gt;&gt; &gt; 这是二级引用&gt; &gt;&gt; &gt; &gt; 这是三级引用&gt; 这是一级引用 三、代码块使用 3 个连续的` 符号包围起来表示代码块。可以指定语言来使代码高亮。 示例 12345$(document).ready(function() &#123; $(&#39;pre code&#39;).each(function(i, block) &#123; hljs.highlightBlock(block); &#125;);&#125;); 12345$(document).ready(function () &#123; $(\"pre code\").each(function (i, block) &#123; hljs.highlightBlock(block); &#125;);&#125;); 行内代码 使用``表示行内代码。本页部分文字中间的英文字母就是使用行内代码标记标记的。 示例 这是 javascript 代码 1这是&#96;javascript&#96;代码 四、链接使用 [](link) 表示行内链接。其中： [] 内的内容为要添加链接的文字。 link 为链接地址。 示例 这是跳转百度的链接 1这是跳转[百度](https:&#x2F;&#x2F;www.baidu.com)的链接 五、导入图片使用 ![Alt text](/path/to/img.jpg) 导入图片。其中： Alt text 为如果图片无法显示时显示的文字； /path/to/img.jpg 为图片所在路径； 本地引用是图片直接存储到本地通过相对路径引用，无需网络连接 上传图片将把图片上传至图床，这样在文档或图片移动时认可访问图片 示例 1![Markdown](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;03&#x2F;14&#x2F;I8wCZN4r9UltqTd.jpg) 六、Todo List小写 x 表示已完成， 空格表示未完成 支持数学公式 支持 TodoList 支持自定义样式 支持自定义图床 1234- [x] 支持数学公式- [x] 支持TodoList- [x] 支持自定义样式- [ ] 支持自定义图床 七、粗体，斜体，高亮和删除线 使用 ** 表示粗体。 1**粗体** 使用 * 或者 _ 表示 _斜体_。 1*斜体* 使用 *** 表示 全部粗体和斜体 1***全部粗体和斜体*** 使用 == 表示 ==高亮== ❗ 部分编辑器不支持高亮 1&#x3D;&#x3D;高亮&#x3D;&#x3D; 使用~~表示 删除 1~~删除~~ 八、列表使用 1. 1. 1. 表示有序列表，使用 * 或 - 或 + 表示无序列表。 无序列表或有序列表标记和后面的文字之间要有一个空格隔开。 有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例 1 所示。 无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的，如例 2 所示。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。 _示例 1_：有序列表 第 1 行 第 2 行 第 3 行 1231. 第1行1. 第2行1. 第3行 _示例 2_：无序列表 一级无序列表内容 二级无序列表内容 三级无序列表内容 一级无序列表内容 1234+ 一级无序列表内容 - 二级无序列表内容 - 三级无序列表内容* 一级无序列表内容 九、分割线使用 --- 或者 *** 或者 * * * 表示水平分割线。 只要 * 或者 - 大于等于三个就可组成一条平行线。 使用 --- 作为水平分割线时，要在它的前后都空一行，防止 --- 被当成标题标记的表示方式。 示例 12345---**** * * 十、表格默认表格Heading | Heading | Heading——- | ——- | ——-Cell | Cell | CellCell | Cell | Cell 1234Heading | Heading | Heading------- | ------- | -------Cell | Cell | CellCell | Cell | Cell 对齐方式：Heading | Heading | Heading:—– | :—-: | ——:Left | Center | RightLeft | Center | Right 1234Heading | Heading | Heading:----- | :----: | ------:Left | Center | RightLeft | Center | Right 十一、emoji使用 :emoji代码: 在 markdown 里添加 emoji 👻 点击这里查看所有支持的 emoji 代码 ❗ 部分编辑器不支持 emoji code 建议直接输入 emoji，点击这里查看并复制 emoji","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://superliebe.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://superliebe.github.io/tags/Markdown/"}]},{"title":"kbone+vue创建支持web和微信小程序的项目","slug":"kbone-vue创建支持web和微信小程序的项目","date":"2020-04-26T07:28:52.000Z","updated":"2020-07-01T07:58:50.343Z","comments":true,"path":"2020/04/26/kbone-vue创建支持web和微信小程序的项目/","link":"","permalink":"http://superliebe.github.io/2020/04/26/kbone-vue%E5%88%9B%E5%BB%BA%E6%94%AF%E6%8C%81web%E5%92%8C%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%B9%E7%9B%AE/","excerpt":"Kbone 是腾讯开发的解决微信小程序和 Web 端同构的框架。简单来说就是只写一套代码，编译结果可以在 web 端和小程序上运行。","text":"Kbone 是腾讯开发的解决微信小程序和 Web 端同构的框架。简单来说就是只写一套代码，编译结果可以在 web 端和小程序上运行。 Kbone 特点 支持多种前端框架，如：vue、react、preact 等，并且能够保持该框架的完整； 页面渲染的内容需要用 js 中的 document 方法来渲染，提供常用的 DOM/BOM 接口； 小程序端开发仍可使用小程序本身特性； 更专注于微信和小程序的开发； Webpack 与 Kbone 是强耦合的，开发需借助 Webpack 提供的基本依赖 一：安装 kbone-cli命令行安装kbone-cli脚手架，用于创建kbone项目 1cnpm install -g kbone-cli 二：创建对应的 kbone 项目1kbone init my-app 可以根据自己所用到的技术选择对应的选项（本项目采用kbone+vue），回车确定。 创建成功之后，基本目录情况和 vue-cli4 目录差不多，其中在 build 文件夹里 miniprogram.config.js 进行小程序的配置，比如 appid 之类 三：在 main.js 中引入 kbone-ui，使项目 ui 更贴近微信风格（可选）安装 kbone-ui 1npm i kbone-ui main.js 中引入样式文件 1234import KboneUI from \"kbone-ui\";import \"kbone-ui/lib/weui/weui.css\";Vue.use(KboneUI); 四：运行项目12345678&#x2F;&#x2F; 开发小程序端npm run mp&#x2F;&#x2F; 开发 Web 端npm run web&#x2F;&#x2F; 构建 Web 端npm run build web端运行效果图 小程序端运行效果图npm run mp 之后 会在dis文件中创建对应的小程序文件，使用微信开发者工具打开预览， 注意：官方提醒，尽量使用kbone-ui开发，目前功能正在逐步完善兼容，使用其他组件库可能会出现问题 kbone 官方文档","categories":[{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"微信小程序","slug":"vue/微信小程序","permalink":"http://superliebe.github.io/categories/vue/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"kbone,vue","slug":"kbone-vue","permalink":"http://superliebe.github.io/tags/kbone-vue/"}]}],"categories":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/categories/docker/"},{"name":"git","slug":"git","permalink":"http://superliebe.github.io/categories/git/"},{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/categories/vue/"},{"name":"node","slug":"vue/node","permalink":"http://superliebe.github.io/categories/vue/node/"},{"name":"koa","slug":"koa","permalink":"http://superliebe.github.io/categories/koa/"},{"name":"linux","slug":"linux","permalink":"http://superliebe.github.io/categories/linux/"},{"name":"Markdown","slug":"Markdown","permalink":"http://superliebe.github.io/categories/Markdown/"},{"name":"微信小程序","slug":"vue/微信小程序","permalink":"http://superliebe.github.io/categories/vue/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://superliebe.github.io/tags/docker/"},{"name":"git","slug":"git","permalink":"http://superliebe.github.io/tags/git/"},{"name":"vue","slug":"vue","permalink":"http://superliebe.github.io/tags/vue/"},{"name":"nodejs,koa","slug":"nodejs-koa","permalink":"http://superliebe.github.io/tags/nodejs-koa/"},{"name":"npm,yarn","slug":"npm-yarn","permalink":"http://superliebe.github.io/tags/npm-yarn/"},{"name":"linux","slug":"linux","permalink":"http://superliebe.github.io/tags/linux/"},{"name":"Markdown","slug":"Markdown","permalink":"http://superliebe.github.io/tags/Markdown/"},{"name":"kbone,vue","slug":"kbone-vue","permalink":"http://superliebe.github.io/tags/kbone-vue/"}]}